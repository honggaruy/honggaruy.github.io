<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>2021년 04주차 기록 - 홍가뤼의 개인위키</title>

    <meta name="description" content="01/25 (월) ~ 01/31 (일)">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://honggaruy.github.io/blog/2021/01/25/week-04th/">
    <link rel="alternate" type="application/rss+xml" title="홍가뤼의 개인위키" href="https://honggaruy.github.io/feed.xml">

    <meta property="og:type" content="website">
    <meta property="og:title" content="2021년 04주차 기록">
    <meta property="og:description" content="01/25 (월) ~ 01/31 (일)">
    <meta property="og:image" content="https://honggaruy.github.io/resources/icon/apple-touch-icon.png">
    <meta property="og:url" content="https://honggaruy.github.io/blog/2021/01/25/week-04th/">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:url" content="https://honggaruy.github.io/blog/2021/01/25/week-04th/">
    <meta name="twitter:title" content="2021년 04주차 기록">
    <meta name="twitter:description" content="01/25 (월) ~ 01/31 (일)">

    <link rel="apple-touch-icon" sizes="180x180" href="/resources/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/icon/favicon-16x16.png">
    <link rel="manifest" href="/resources/icon/site.webmanifest">




</head>
<body>
<header class="header">
    <div>
        <a class="site-title" href="/">홍가뤼의 개인위키</a>
    </div>
    <div>
        <a class="site-title-right" href="/about/">me</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/#random" onclick="if(typeof random === 'function')random()">random</a>
    </div>
    <div>
        <a class="site-title-right" href="/blog/">blog</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/">wiki</a>
    </div>
</header>

    
        <div class="page-content">
            <div class="search">
    <form role="search" method="get" action="/search/">
         <input name="searchString" class="searchInput" placeholder=" 검색하세요" type="text">
         <input type="submit" class="searchButton" value="Search">
    </form>
</div>
            <div class="post">
                <div class="post">
    <header class="post-header">

        <div class="PageNavigation">
          
            <a class="prev" href="/blog/2021/01/18/week-03th/">« 2021년 03주차 기록</a>
          
          
            <a class="next" href="/blog/2021/02/01/week-05th/">2021년 05주차 기록 »</a>
          
        </div>

        <h1 class="post-title blog-only-title">2021년 04주차 기록</h1>
        <p class="created-date">
            2021.01.25
        </p>


        <div class="post-tag">
    test-console mocha chai test translation compare 비교 npm-trends
</div>

        <h2>01/25 (월) ~ 01/31 (일)</h2>
    </header>


    <div class="toc">
    </div>

    <article class="post-content">
        <ul id="markdown-toc">
  <li>
<a href="#%ED%84%B0%EB%AF%B8%EB%84%90-%EC%B6%9C%EB%A0%A5-%EC%9E%90%EC%B2%B4%EB%A5%BC-mocha%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0" id="markdown-toc-터미널-출력-자체를-mocha로-테스트하기">터미널 출력 자체를 Mocha로 테스트하기</a>    <ul>
      <li><a href="#test-console" id="markdown-toc-test-console">test-console</a></li>
    </ul>
  </li>
  <li>
<a href="#%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%ED%95%A8%EC%88%98%EB%A5%BC-mocha%EC%99%80-chai%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%98%EA%B8%B0" id="markdown-toc-비동기식-함수를-mocha와-chai로-테스트-하기">비동기식 함수를 mocha와 chai로 테스트 하기</a>    <ul>
      <li><a href="#%EB%B2%88%EC%97%AD---modern-nodejs-asyncawait-based-testing-with-mocha--chai" id="markdown-toc-번역---modern-nodejs-asyncawait-based-testing-with-mocha--chai">번역 - Modern Node.js: async/await based testing with Mocha &amp; Chai</a></li>
    </ul>
  </li>
  <li>
<a href="#html%EC%9D%84-parse-%ED%95%98%EB%8A%94-library%EC%9D%98-%EB%B9%84%EA%B5%90" id="markdown-toc-html을-parse-하는-library의-비교">html을 parse 하는 library의 비교</a>    <ul>
      <li>
<a href="#parsing-html-a-guide-to-select-the-right-library-strumenta" id="markdown-toc-parsing-html-a-guide-to-select-the-right-library-strumenta">Parsing HTML: A Guide to Select the Right Library, STRUMENTA</a>        <ul>
          <li>
<a href="#nodejs" id="markdown-toc-nodejs">NODE.js</a>            <ul>
              <li><a href="#cheerio" id="markdown-toc-cheerio">Cheerio</a></li>
              <li><a href="#jsdom" id="markdown-toc-jsdom">Jsdom</a></li>
              <li><a href="#htmlparser2-and-related-libraries" id="markdown-toc-htmlparser2-and-related-libraries">Htmlparser2 and related libraries</a></li>
              <li><a href="#parse5" id="markdown-toc-parse5">Parse5</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="터미널-출력-자체를-mocha로-테스트하기">터미널 출력 자체를 Mocha로 테스트하기</h1>

<ul>
  <li>Open API test시에 터미널로 출력되는 메시지를 테스트하고 싶어졌다.</li>
  <li>
<a href="https://stackoverflow.com/q/18543047/9457247">stack overflow에 관련 질문이 있었다</a>
    <ul>
      <li><a href="https://stackoverflow.com/a/36043374/9457247">답변중 테스트 해보고 싶은 후보</a></li>
    </ul>
  </li>
</ul>

<h2 id="test-console">test-console</h2>

<ul>
  <li>
<a href="https://github.com/jamesshore/test-console">test-console, github</a>
    <ul>
      <li><a href="https://www.jamesshore.com/">개발자도 유명한 사람인듯..</a></li>
      <li>사용자 반응도 괜찮아보임.</li>
    </ul>
  </li>
</ul>

<h1 id="비동기식-함수를-mocha와-chai로-테스트-하기">비동기식 함수를 mocha와 chai로 테스트 하기</h1>

<ul>
  <li>#mocha, #chai</li>
  <li>Open API Test 에서 api 호출함수들은 비동기식으로 동작한다</li>
  <li>때문에 바로 결과를 확인할 경우 결과가 안나올수 있다.</li>
  <li>관련 내용이 있는지 찾아봤다.</li>
  <li>
<a href="https://zaiste.net/posts/modern-nodejs-async-await-testing-mocha-chai/">Modern Node.js: async/await based testing with Mocha &amp; Chai</a>
    <ul>
      <li>2017년 4월 9일 내용임</li>
    </ul>
  </li>
</ul>

<h2 id="번역---modern-nodejs-asyncawait-based-testing-with-mocha--chai">번역 - Modern Node.js: async/await based testing with Mocha &amp; Chai</h2>

<ul>
  <li>#translation</li>
  <li>Mocha는 Node.js 환경이나 브라우저환경에서 실행되는 Javascript 테스트 프레임웍이다</li>
  <li>Mocha는 비동기 와 동기 코드를 직렬로(serially) 모두 실행할 수 있다.</li>
  <li>테스트 케이스는 <code class="language-html highlighter-rouge">describe()</code>와 <code class="language-html highlighter-rouge">it()</code> 메소드를 이용하여 생성된다.
    <ul>
      <li>
<code class="language-html highlighter-rouge">describe()</code>는 논리적으로 그루핑할 수있는 다양한 케이스를 포함하는 구조를 제공하는데 사용되고
        <ul>
          <li>
<code class="language-html highlighter-rouge">it()</code>는 테스트 자체가 쓰여진다</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>실제 테스트를 수행하기 위해, assertion 라이브러리가 필요하다
    <ul>
      <li>assertion 라이브러리는 프로그램에 의해 가정된 결과를 검증하기 위해 쓰이는 실행 메커니즘이다.</li>
      <li>assertion 라이브러리는 또한 가정이 fail이 나면 진단 메시지를 출력한다.</li>
    </ul>
  </li>
  <li>Node.js는 내장 assert 라이브러리가 있지만 …
    <ul>
      <li>
<code class="language-html highlighter-rouge">Chai</code>는 테스팅코드에 <code class="language-html highlighter-rouge">BDD</code>혹은 <code class="language-html highlighter-rouge">TDD</code>스타일의 프로그래밍을 모두 제공하는 인기있는 라이브러리이다.</li>
      <li>
<code class="language-html highlighter-rouge">BDD</code>는 <code class="language-html highlighter-rouge">Behavior-driven development</code>를 의미한다.</li>
      <li>
<code class="language-html highlighter-rouge">TDD</code>는 <code class="language-html highlighter-rouge">Test-driven development</code>를 의미한다.</li>
      <li>간단히 말하면, Chai는 BDD 스타일을 위해 chain assertion을 허용하는  <code class="language-html highlighter-rouge">should</code> 키워드를 제공한다.</li>
      <li>또한, TDD 스타일을 위해 <code class="language-html highlighter-rouge">expect()</code>를 지원한다.</li>
      <li>둘 중에 어떤 스타일을 선택할 지는 개인의 선호도에 따른다.</li>
    </ul>
  </li>
  <li>
<code class="language-html highlighter-rouge">should</code>를 사용한 <code class="language-html highlighter-rouge">BDD</code> 스타일 예제 ( 좀더 영어문장스럽다.)
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre><span class="nx">chai</span><span class="p">.</span><span class="nx">should</span><span class="p">();</span>
  
<span class="nx">foo</span><span class="p">.</span><span class="nx">should</span><span class="p">.</span><span class="nx">be</span><span class="p">.</span><span class="nx">a</span><span class="p">(</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">should</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">should</span><span class="p">.</span><span class="nx">have</span><span class="p">.</span><span class="nx">lengthOf</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">tea</span><span class="p">.</span><span class="nx">should</span><span class="p">.</span><span class="nx">have</span><span class="p">.</span><span class="nx">property</span><span class="p">(</span><span class="dl">'</span><span class="s1">flavors</span><span class="dl">'</span><span class="p">).</span><span class="kd">with</span><span class="p">.</span><span class="nx">lengthOf</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
<code class="language-html highlighter-rouge">expect</code>를 사용한 <code class="language-html highlighter-rouge">TDD</code> 스타일 예제
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">expect</span> <span class="o">=</span> <span class="nx">chai</span><span class="p">.</span><span class="nx">expect</span><span class="p">;</span>
  
<span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">be</span><span class="p">.</span><span class="nx">a</span><span class="p">(</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">have</span><span class="p">.</span><span class="nx">lengthOf</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">tea</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">have</span><span class="p">.</span><span class="nx">property</span><span class="p">(</span><span class="dl">'</span><span class="s1">flavors</span><span class="dl">'</span><span class="p">).</span><span class="kd">with</span><span class="p">.</span><span class="nx">lengthOf</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
<code class="language-html highlighter-rouge">async/awit</code>를 이용한 비동기 코드를 테스트하기 위해 한군데 몰아넣자.
    <ul>
      <li>여기에 비동기 <code class="language-html highlighter-rouge">add()</code> 함수가 있다.</li>
      <li>Mocha와 Chai를 <code class="language-html highlighter-rouge">expect</code> 스타일로 조합하고 <code class="language-html highlighter-rouge">async/await</code> ES7 문법을 사용한다.
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">expect</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">chai</span><span class="dl">'</span><span class="p">).</span><span class="nx">expect</span><span class="p">;</span>
    
<span class="k">async</span> <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
      
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">#add()</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">2 + 2 is 4</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">p</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">3 + 3 is 6</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">p</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
<code class="language-html highlighter-rouge">async/await</code> 문법으로  <code class="language-html highlighter-rouge">chai-as-promised</code> 같은 플러그인은 더이상 필요없어졌다.
    <ul>
      <li>프로미스에 대해 fact를 assert 할 필요가 없어졌기 때문</li>
      <li>단순히 값들만 다루면 된다.</li>
    </ul>
  </li>
  <li>Mocha에 lambda나 arrow function을 넘기는 것도 추천하지 않는다.
    <ul>
      <li>Mocha helper function( 어휘적으로 lexically <code class="language-html highlighter-rouge">this</code>에 결합됨)  에 접근하는 것이 불가능하기 때문에..</li>
      <li>사실상 그런 함수들은 거의 쓰이지 않음.</li>
    </ul>
  </li>
  <li>실행하기위해 Node.js 프로젝트를 생성하자
    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="o">&gt;</span> <span class="nb">mkdir </span>async-await-mocha-chai-example
<span class="o">&gt;</span> <span class="nb">cd </span>async-await-chai-example
<span class="o">&gt;</span> yarn init <span class="nt">-y</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
    <ul>
      <li>(역자주) yarn은 npm 비슷한 패키지 매니저인데 npm의 단점을 개선하려고 만듬</li>
    </ul>
  </li>
  <li>다음은, <code class="language-html highlighter-rouge">mocha</code>와 <code class="language-html highlighter-rouge">chai</code>를 dev dependency로 설치한다.
    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="o">&gt;</span> yarn add mocha chai <span class="nt">--dev</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>마지막으로 테스트코드를 <code class="language-html highlighter-rouge">test/add.test.js</code> 안에 두고 실행해보자
    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td>
<td class="rouge-code"><pre><span class="o">&gt;</span> yarn run mocha
  
yarn run mocha
    
  <span class="c">#add()</span>
    √ 2 + 2 is 4
    √ 3 + 3 is 6
    
  4 passing <span class="o">(</span>199ms<span class="o">)</span>
    
  Done <span class="k">in </span>0.99s.
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>좀 더 편하게, <code class="language-html highlighter-rouge">test</code>명령을 <code class="language-html highlighter-rouge">package.json</code>의 <code class="language-html highlighter-rouge">scripts</code> 섹션에 두어도 된다.
    <div class="language-json highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"mocha --reporter list"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>이런 방식으로 <code class="language-html highlighter-rouge">yarn run test</code> 와 같이 테스트를 실행할수 있다.
    <ul>
      <li>
<code class="language-html highlighter-rouge">--reporter</code>와 같은 기본옵션을 한번만 설정하면 모든 테스트에 동일하게 적용가능하다.</li>
      <li>어떤 Mocha 테스트가 <code class="language-html highlighter-rouge">-g <span class="nt">&lt;pattern&gt;</span></code>이나 <code class="language-html highlighter-rouge">-f <span class="nt">&lt;substring&gt;</span></code> 옵션을 사용할지 선택할 수 있다.</li>
    </ul>
  </li>
  <li>Mocha는 <code class="language-html highlighter-rouge">before()</code>와 <code class="language-html highlighter-rouge">after()</code>같은 hook 메소드도 지원한다.
    <ul>
      <li>이런 hook은 모든 테스트의 사전과 사후의 외부 자원을 관리(설정과 해체)하는데 사용된다.</li>
      <li>특정 테스트용으로는 <code class="language-html highlighter-rouge">beforeEach()</code>와 <code class="language-html highlighter-rouge">afterEach()</code>가 있다.</li>
    </ul>
  </li>
  <li>데이타베이스 지속성을 테스트하는 예제가 있다.
    <ul>
      <li>데이타베이스 연결은 모든 테스트전에 한번만 수행하면 된다.</li>
      <li>데이타베이스는 각 테스트 전에 처음부터 초기화되므로 각각의 테스트는 동일한 초기 상태에서 시작하게된다.
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">expect</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">chai</span><span class="dl">'</span><span class="p">).</span><span class="nx">expect</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Sequelize</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">sequelize</span><span class="dl">'</span><span class="p">);</span>
    
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">users</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">database</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">User</span><span class="p">;</span>
      
  <span class="nx">before</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">database</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Seuelize</span><span class="p">(</span><span class="dl">'</span><span class="s1">postgresql://localhost/app_test</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">logging</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
    <span class="nx">User</span> <span class="o">=</span> <span class="nx">database</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">usernaem</span><span class="p">:</span> <span class="nx">Sequelize</span><span class="p">.</span><span class="nx">STRING</span><span class="p">,</span>
      <span class="na">birthday</span><span class="p">:</span> <span class="nx">Seuelize</span><span class="p">.</span><span class="nx">DATE</span>
    <span class="p">});</span>
  <span class="p">})</span>
      
  <span class="nx">beforeEach</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">User</span><span class="p">.</span><span class="nx">sync</span><span class="p">();</span>
    <span class="k">await</span> <span class="nx">User</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
      <span class="na">username</span><span class="p">:</span> <span class="dl">'</span><span class="s1">zaiste</span><span class="dl">'</span><span class="p">,</span> 
      <span class="na">birthday</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">1988</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> 
    <span class="p">});</span>
  <span class="p">})</span>
      
  <span class="nx">afterEach</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">User</span><span class="p">.</span><span class="nx">drop</span><span class="p">();</span>
  <span class="p">})</span>
      
  <span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">#find()`, () =&gt; {
    it(</span><span class="dl">'</span><span class="nx">should</span> <span class="nx">find</span> <span class="nx">a</span> <span class="nx">user</span><span class="dl">'</span><span class="s1">, async () =&gt; {
      const user = await User.findOne({ where: { username: </span><span class="dl">'</span><span class="nx">zaiste</span><span class="dl">'</span><span class="s1"> }})
      expect(user).to.be.a(</span><span class="dl">'</span><span class="nx">object</span><span class="dl">'</span><span class="s1">);
      expect(user).to.have.property(</span><span class="dl">'</span><span class="nx">username</span><span class="dl">'</span><span class="s1">);
      expect(user).to.have.propety(</span><span class="dl">'</span><span class="nx">birthday</span><span class="dl">'</span><span class="s1">);
      expect(user.username).to.equal(</span><span class="dl">'</span><span class="nx">zaiste</span><span class="dl">'</span><span class="s1">);
    });
  });
});
</span></pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>마지막으로 Mocha는 테스트 케이스 옆에 잡히지 않은 예외를 출력하여..
    <ul>
      <li>.. 각 테스트별로 실패한 곳과 그 이유를 구분되도록 합니다.</li>
    </ul>
  </li>
</ul>

<h1 id="html을-parse-하는-library의-비교">html을 parse 하는 library의 비교</h1>

<ul>
  <li>
<a href="https://www.npmtrends.com/cheerio-vs-htmlparser2-vs-jsdom-vs-parse5-vs-scraper">cheerio vs htmlparser2 vs jsdom vs parse5 vs scraper, npm trends</a>
    <ul>
      <li>parse5가 download 1위, htmlparser2가 간발의차 2위, jsdom이 3위</li>
      <li>star는 cheerio 가 23,272로 1위 , jsdom이 15,298로 2위 .. 역시 전통의 강자</li>
      <li>
<a href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md">parse5</a>를 써보기로 함.</li>
    </ul>
  </li>
</ul>

<h2 id="parsing-html-a-guide-to-select-the-right-library-strumenta"><a href="https://tomassetti.me/parsing-html/">Parsing HTML: A Guide to Select the Right Library, STRUMENTA</a></h2>

<ul>
  <li>#translation</li>
  <li>언어별 HTML을 파싱하는 라이브러리를 소개하는 내용</li>
  <li><a href="https://tomassetti.me/category/language-engineering/parsing/page/2/">2017년 9월 21일자 내용</a></li>
  <li>알아야할 용어
    <ul>
      <li>
<a href="https://ko.wikipedia.org/wiki/WHATWG">WHATWG</a> : 웹 하이퍼텍스트 애플리케이션 테크놀로지 워킹 그룹</li>
      <li>WHATWG DOM &amp; HTML : 위 단체에서 정한 웹 규격</li>
    </ul>
  </li>
</ul>

<h3 id="nodejs">NODE.js</h3>

<ul>
  <li>Node.js는 web으로 쉽게 작업할수 있지만,…
    <ul>
      <li>브라우저처럼 손쉽게 파싱 기능을 사용할 수 있는건 아니다.</li>
      <li>이런 의미에서, Node.js의 JavasCript는 전통적인 언어와 비슷한 입장이다.</li>
      <li>즉, parsing 작업은 개발자 자신이 직접 처리해야한다.</li>
    </ul>
  </li>
</ul>

<h4 id="cheerio">Cheerio</h4>

<blockquote>
  <p>서버를 위해 특별히 설계된 core jQuery의 빠르고, 유연하며, 간결한 구현</p>
</blockquote>

<ul>
  <li>
<a href="https://cheerio.js.org/">Cheerio</a>는 <code class="language-html highlighter-rouge">서버에서 동작하는 jQuery</code> 이다.</li>
  <li>이것이 명확한 설명이지만, 어쨌든 좀 더 설명하겠다
    <ul>
      <li>jQuery처럼 보이지만, 브라우저가 존재하지 않는다.</li>
      <li>즉, Cheerio는 HTML을 파싱하고 다루기 쉽게하지만, 실제 렌더링이 일어나지는 않는다.</li>
      <li>브라우저에서 하는 것처럼 HTML을 처리하지 않는다.
        <ul>
          <li>브라우저와 다르게 구문을 분석한다는 의미에서나..</li>
          <li>분석 결과가 곧장 사용자에게 전달되는게 아니라는 점에서 모두 브라우저와는 다르다</li>
          <li>그런 작업이 필요하다면 사용자가 직접 처리해야한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Cheerio는 몇가지 jQuery 유틸리티 함수를 포함한다.
    <ul>
      <li>
<code class="language-html highlighter-rouge">slice</code>나 <code class="language-html highlighter-rouge">eq</code> 같이 범위를 조절하기 위한 함수이다.</li>
      <li>데이타를 배열 이름과 form elements의 값으로 serialize 할 수 있지만,</li>
      <li>jQuery가 하는 것처럼 server에 그것들을 제출할 수는 없다.
        <ul>
          <li>Node.js가 서버상에서 동작하기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>개발자는 jsdom의 가벼운 버전의 대체제를 원했기 때문에 이 라이브러리를 개발했다.
    <ul>
      <li>이 라이브러리는 또한 더 빠르고 파싱에 덜 엄격하다.</li>
      <li>실제적이고 지저분한 웹사이트를 파싱하기 위한 이유도 있습니다.</li>
    </ul>
  </li>
  <li>Cheerio 의 문법은 JavaScript 개발자에게 아주 익숙합니다.
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">cheerio</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">cheerio</span><span class="dl">'</span><span class="p">),</span>
  <span class="nx">$</span> <span class="o">=</span> <span class="nx">cheerio</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;h3 class = "title"&gt;I am here~&lt;/h3&gt;</span><span class="dl">'</span><span class="p">);</span>
    
<span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">h3.title</span><span class="dl">'</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="dl">'</span><span class="s1">There i nobody here!</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">h3</span><span class="dl">'</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">in_hiding</span><span class="dl">'</span><span class="p">);</span>
  
<span class="nx">$</span><span class="p">.</span><span class="nx">html</span><span class="p">();</span>
<span class="c1">//=&gt; &lt;h3 class = "title" id="in_hiding"&gt;Thfer is nobody here!&lt;/h3&gt;</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>위 설명은 프로젝트의 긴 README 보다 제한적이지만, 당신이 필요한 설명이 대부분 있을것이다.</li>
</ul>

<h4 id="jsdom">Jsdom</h4>

<blockquote>
  <p><a href="https://github.com/jsdom/jsdom">jsdom</a> 은 Node.js와 함께 사용하기 위한 많은 web 표준, 특히 WHATWG <a href="https://dom.spec.whatwg.org/">DOM</a> 및 <a href="https://html.spec.whatwg.org/multipage/">HTML</a> 표준의 순수 Javasciprt 구현이다.
일반적으로 이 프로젝트의 목표는 실제 웹 애플리케이션을 테스트하고 스크래핑하는 데 유용 할 수 있도록
웹 브라우저의 하위 집합을 충분히 에뮬레이션하는 것입니다.</p>
</blockquote>

<ul>
  <li>그래서 jsdom은 HTML parser라기 보다는 브라우저처럼 동작합니다.
    <ul>
      <li>파싱의 context에서 jsdom은 당신이 파싱하려는 데이타에서 필요한 태그를 누락한다면 jsdom이 자동적으루 추가한다는 의미이다.</li>
      <li>예를들어 html tag가 없다면 브라우저가 의례 그렇듯 묵시적으로 html tag를 추가한다.</li>
    </ul>
  </li>
  <li>DOM 표준을 지원한다는 것은
    <ul>
      <li>jsdom object가 <code class="language-html highlighter-rouge">document</code>나 <code class="language-html highlighter-rouge">window</code>처럼 친숙한 속성을 가지며</li>
      <li>DOM을 다루는 것이 일반 javascript를 사용하는것과 다를바 없을것을 의미한다.</li>
    </ul>
  </li>
  <li>document, referrer, user agent의 URL과 같은 몇가지 속성을 선택저으로 지장할 수도 있다.
    <ul>
      <li>URL은 로컬 URL이 포함된 링크를 분석해야할 경우 특히 유용하다.</li>
    </ul>
  </li>
  <li>파싱과 실제로 관련이 없기 때문에, jsdom이 (가상) console, 쿠키 지원이 존재한다고만 언급한다.
    <ul>
      <li>간단히 말해서 브라우저 환경을 시뮬레이션하는데 필요한 모든 것이다.</li>
      <li>그것은 또한 외부 리소스, 심지어 javascript 스크립트도 처리할 수 있다.</li>
      <li>즉, 당신이 원한다면 (자바스크립트를) 로드하고 실행시킬수도 있다.</li>
      <li>어떤 외부 코드를 실행할 때라도 항상 그런것처럼 보안상의 이슈가 있을수 있음에 주목해라</li>
      <li>문서상에 관련 주의사항이 있으니 읽어볼것</li>
    </ul>
  </li>
  <li>주목할 또다른 내용은 파싱이 일어나기전 환경을 변경할 수 있다는 점이다.</li>
  <li>예를들면, jsdom 파서가 지원하지 않는 기능을 시뮬레이트할 Javascript를 추가할 수 있다.</li>
  <li>이런 라이브러리들은 <code class="language-html highlighter-rouge">shims</code>라고 불린다.
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">jsdom</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">jsdom</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">JSDOM</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">jsdom</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JSDOM</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;!DOCTYPE html&gt;&lt;p&gt;Goodbye world&lt;/p&gt;</span><span class="dl">'</span><span class="p">);</span>
  
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dom</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">).</span><span class="nx">textContent</span><span class="p">);</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>관련 문서는 충분히 좋다.</li>
  <li>프로젝트의 방대함에 비해 놀라울 정도로 짧지만,
    <ul>
      <li>DOM을 사용하기 위한 문서들은 다른곳에서 찾을 수 있기에</li>
      <li>짧아도 그럭저럭 넘어갈수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="htmlparser2-and-related-libraries">Htmlparser2 and related libraries</h4>

<ul>
  <li>
<a href="https://github.com/fb55">Felix Böhm</a> 이
    <ul>
      <li>
<a href="https://github.com/fb55/htmlparser2">HTML (XML and RSS)</a> , <a href="https://github.com/fb55/css-select">CSS selecter</a> 를 파싱하고</li>
      <li>
<a href="https://github.com/fb55/domhandler">DOM</a> 을 구축하는 몇가지 라이브러리를 만들었다.</li>
      <li>매우 성공적이었고, 심지어 cheerio 라이브러리를 강력하게 하는데도 충분히 좋다.</li>
      <li>라이브러리는 분리하여 사용해도 되지만, 함께 사용될 수 있다.</li>
    </ul>
  </li>
  <li>HTML 파서는 빠르지만, 매우 기본적이다.</li>
  <li>아래 예제는 태그나 텍스트 요소를 만날때 단지 함수만 실행시키면 되는것을 보여준다.
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
<td class="rouge-code"><pre><span class="c1">// from the documentation</span>
<span class="kd">var</span> <span class="nx">htmlparser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">htmlparser2</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">htmlparser</span><span class="p">.</span><span class="nx">Parser</span><span class="p">({</span>
  <span class="na">onopentag</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">attribs</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">name</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">srcipt</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">attribs</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">JS! Hooray!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">ontext</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">--&gt;</span><span class="dl">"</span><span class="p">,</span> <span class="nx">text</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">{</span><span class="na">decodeEntities</span><span class="p">:</span> <span class="kc">true</span><span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">Xyz &lt;script type='text/javascript'&gt;var foo = '&lt;&lt;bar&gt;&gt;';&lt;/script&gt;</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>HTML 문서의 복잡한 고급 조작이 필요한 경우 강력하고 훌륭하다.</li>
  <li>하지만, 간단한 HTML 파싱이나 간단한 DOM 조작을 하려고할 때는,
    <ul>
      <li>라이브러리를 함께 사용하더라도 다소 투박하다.</li>
      <li>부분적으로, 이것은 기능 자체 때문이다.</li>
      <li>예를 들면, DOM 라이브러리는 단지 DOM을 빌드만하며, 이것을 다루는 helper함수가 없다.</li>
      <li>실제로 DOM을 조작하려면 domutils라는 또 다른 라이브러리가 필요한데,
        <ul>
          <li>domutils는 문자그대로 전혀 문서화가 안되어 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>하지만, 진짜 이슈는 각 기능위에서 통합하는 기능은 제공하지 않으며, 단지 같이 동작하기만 한다는 것이다
    <ul>
      <li>대부분 고급 구문 분석 요구를 위해 설계되었다.</li>
      <li>예를 들면, 내부에서 HTML을 사용하는 워드프로세서를 만들려고 할때는 대단히 유용하다.</li>
      <li>이런 목적이 아니라면, 다른 것을 찾아봐야할것이다?</li>
    </ul>
  </li>
  <li>이런 사용하기 어려운점은 제한된 문서화때문이다. 좋은 부분은 CSS selector 엔진뿐이다.</li>
</ul>

<h4 id="parse5">Parse5</h4>

<blockquote>
  <p>parse5는 당신이 HTML을 다룰 때 필요한 거의 대부분의 기능을 지원한다.</p>
</blockquote>

<ul>
  <li>Parse5는 다른 도구를 만들기 위한 라이브러이지만 간단한 HTML 분석에 직접사용할 수도 있다.</li>
  <li>하지만 두번째 용도에 대해서는 다소 제한적이다. 아래 예제를 보자
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">parse5</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">parse5</span><span class="dl">'</span><span class="p">);</span>
  
<span class="kd">const</span> <span class="nb">document</span> <span class="o">=</span> <span class="nx">parse5</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hi there!&lt;/body&gt;&lt;/html&gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">tagName</span><span class="p">);</span> <span class="c1">//=&gt; 'html'</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>사용하기는 쉽지만, 이슈는 브라우저가 DOM을 다룰 때 제공하는 도구를 제공하지 않는데에 있다. (예를 들면, getElementById)</li>
  <li>제한된 문서화로 어려움이 더 증가한다: API reference 관련 질문에 대한 답변의 연속으로 이루어져있다.</li>
  <li>(예를 들면, “HTML 문자열을 파싱하고 싶다” =&gt; parse5.parse 메소드를 사용하라)</li>
  <li>따라서 간단한 DOM 조작에 사용하는 것이 가능은 하지만 아마도 당신이 그것만 원하지는 않을것이다.</li>
  <li>반면에 parse5는 jsdom, Angular2및 Polymer와 같은 인상적인 프로젝트 시리즈를 나열한다.</li>
  <li>따라서 HTML의 고급 조작 또는 구문 분석을 위한 신뢰할 수 있는 기반이 필요한 경우 분명히 좋은 선택이다.</li>
  <li>
</li>
</ul>

    </article>
    <script>
    ;(function() {
        var tags = document.querySelectorAll('.post-tag');
        if(tags == null || tags.length < 1) {
            return;
        }

        for (var i = 0; i < tags.length; i++) {
            var item = tags[i];
            var tagList = item.innerHTML.trim();

            if(/^\s*$/.test(tagList)) {
                continue;
            }
            tagList = tagList.split(/\s+/)
                .map(function(tag) {
                    return `<a href="/tag/#${tag}">#${tag}</a>`;
                })
                .join(' ');
            tags[i].innerHTML = tagList;
        }
        return;
    })();
    ;(function() {
        var post = document.querySelector('article.post-content');

        if(post == null) {
            return;
        }

        (function iterate_node(node) {

            if (/^(?:p|ul|h\d|table)$/i.test(node.tagName)) {

                node.innerHTML = link(node.innerHTML);

            } else { // Node.ELEMENT_NODE
                for (var i = 0; i < node.childNodes.length; i++) {
                    iterate_node(node.childNodes[i]);
                }
            }
        })(post);

        function link(content) {
            content = content.replace(/\\\[\[(.+?)\]\]/g, '\\[\\[$1\\]\\]');
            content = content.replace(/\[\[(.+?)\]\]\{(.+?)\}/g, '<a href="../$1">$2</a>');
            content = content.replace(/\[\[(.+?)\]\]/g, '<a href="../$1">$1</a>');
            content = content.replace(/\\\[\\\[(.+?)\\\]\\\]/g, '[[$1]]');
            return content;
        }

    })();
</script>

    
    <div class="post-comments">
    
    
        <script src="https://utteranc.es/client.js" repo="honggaruy/honggaruy.github.io" issue-term="pathname" label="Comment" theme="github-light" crossorigin="anonymous" async>
        </script>
    
    </div>



</div>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>
</footer>
    
</body>
</html>
