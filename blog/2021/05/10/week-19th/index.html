<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>2021년 19주차 기록 - 홍가뤼의 개인위키</title>

    <meta name="description" content="05/10 (월) ~ 05/16 (일)">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://honggaruy.github.io/blog/2021/05/10/week-19th/">
    <link rel="alternate" type="application/rss+xml" title="홍가뤼의 개인위키" href="https://honggaruy.github.io/feed.xml">

    <meta property="og:type" content="website">
    <meta property="og:title" content="2021년 19주차 기록">
    <meta property="og:description" content="05/10 (월) ~ 05/16 (일)">
    <meta property="og:image" content="https://honggaruy.github.io/resources/icon/apple-touch-icon.png">
    <meta property="og:url" content="https://honggaruy.github.io/blog/2021/05/10/week-19th/">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:url" content="https://honggaruy.github.io/blog/2021/05/10/week-19th/">
    <meta name="twitter:title" content="2021년 19주차 기록">
    <meta name="twitter:description" content="05/10 (월) ~ 05/16 (일)">

    <link rel="apple-touch-icon" sizes="180x180" href="/resources/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/icon/favicon-16x16.png">
    <link rel="manifest" href="/resources/icon/site.webmanifest">




</head>
<body>
<header class="header">
    <div>
        <a class="site-title" href="/">홍가뤼의 개인위키</a>
    </div>
    <div>
        <a class="site-title-right" href="/about/">me</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/#random" onclick="if(typeof random === 'function')random()">random</a>
    </div>
    <div>
        <a class="site-title-right" href="/blog/">blog</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/">wiki</a>
    </div>
</header>

    
        <div class="page-content">
            <div class="search">
    <form role="search" method="get" action="/search/">
         <input name="searchString" class="searchInput" placeholder=" 검색하세요" type="text">
         <input type="submit" class="searchButton" value="Search">
    </form>
</div>
            <div class="post">
                <div class="post">
    <header class="post-header">

        <div class="PageNavigation">
          
            <a class="prev" href="/blog/2021/05/03/week-18th/">« 2021년 18주차 기록</a>
          
          
            <a class="next" href="/blog/2021/05/17/week-20th/">2021년 20주차 기록 »</a>
          
        </div>

        <h1 class="post-title blog-only-title">2021년 19주차 기록</h1>
        <p class="created-date">
            2021.05.10
        </p>


        <div class="post-tag">
    translation terminology
</div>

        <h2>05/10 (월) ~ 05/16 (일)</h2>
    </header>


    <div class="toc">
    </div>

    <article class="post-content">
        <ul id="markdown-toc">
  <li>
<a href="#%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC" id="markdown-toc-용어-정리">용어 정리</a>    <ul>
      <li><a href="#stateless-app" id="markdown-toc-stateless-app">stateless app</a></li>
    </ul>
  </li>
  <li>
<a href="#%EB%B2%88%EC%97%AD-1%EA%B0%9C" id="markdown-toc-번역-1개">번역 1개</a>    <ul>
      <li>
<a href="#javascript-is-a-great-language---if-you-use-typescript-medium" id="markdown-toc-javascript-is-a-great-language---if-you-use-typescript-medium">JavaScript Is A Great Language - If You Use TypeScript, medium</a>        <ul>
          <li><a href="#1-javascript-is-great-for-functional-programming" id="markdown-toc-1-javascript-is-great-for-functional-programming">1. JavaScript Is Great for Functional Programming</a></li>
          <li><a href="#2-js-is-great-for-asynchronous-programming" id="markdown-toc-2-js-is-great-for-asynchronous-programming">2. JS Is Great for Asynchronous Programming</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="용어-정리">용어 정리</h1>

<h2 id="stateless-app">stateless app</h2>

<ul>
  <li><a href="https://www.redhat.com/ko/topics/cloud-native-apps/stateful-vs-stateless">스테이트풀과 스테이트리스 비교, RedHat</a></li>
  <li>
<a href="https://developer.mozilla.org/ko/docs/Learn/Common_questions/What_is_a_web_server#http%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%B4_%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0">웹서버란 무엇인가? MDN</a> : Stateless에 대한 설명이 나옴</li>
  <li>
<a href="https://whatis.techtarget.com/definition/stateless-app">stateless app, WhatIs.com</a> : 스테이트리스 앱에 대한 정의 ( whatis.com 사이트는 기업 email 아이디가 있는 사람만 사용할수 있음. 폐쇄적임. 요건 다행히 오픈되어 있네..)
    <ul>
      <li>한 세션에서 생성된 고객 데이터를 다음 세션에서 사용하기 위해 저장하는 일이 없는 어플리케이션 프로그램
        <ul>
          <li>각 세션은 첫번째 방문인 것처럼 진행되며</li>
          <li>응답이 이전 세션으로부터의 데이타에 의존하지 않는다.</li>
          <li>반면에 <code class="language-html highlighter-rouge">스테이트풀</code> 앱은 각 고객 세션의 데이타를 저장하고 그 고객이 다음번에 request를 하면 저장된 데이타를 사용한다</li>
        </ul>
      </li>
      <li>어떤 앱이 <code class="language-html highlighter-rouge">스테이트리스</code>할 때, 서버는 고객 세션에 대한 어떤 데이타도 저장하지 않는다.
        <ul>
          <li>대신 세션 데이타는 고객측에 저장되며 필요할 때 서버로 전달된다.</li>
          <li>이 것은 <code class="language-html highlighter-rouge">offline first</code>를 염두에 두고 앱을 개발할때 중요한 점이다.</li>
          <li>소프트웨어 개발에서 이런 접근방식에서는,
            <ul>
              <li>인터넷 연결이 안될때에도, 유저 단말기에 세션데이타가 로컬로 저장되며</li>
              <li>인터넷 연결이 복구되면, 세션데이타가 클라우드로 업로드되어 복제된다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>클라우드 컴퓨팅에서 수평적 확장(horizontal scalability)을 가능케하는 분산 아케텍처는..
    <ul>
      <li>
<code class="language-html highlighter-rouge">스테이트리스</code> 앱과 그 구성요소에대한 새로운 관심을 불러일으켰다.</li>
      <li>그 이유중 하나는,
        <ul>
          <li>앱의 구성요소가 <code class="language-html highlighter-rouge">스테이트리스</code>하다면,</li>
          <li>오류가 발생할 때 그 구성요소들을 쉽게 재배포하고</li>
          <li>부하 변동을 수용하도록 확장할 수 있기 때문이다.</li>
        </ul>
      </li>
      <li>또 다른 이유는,
        <ul>
          <li>앱들이 <code class="language-html highlighter-rouge">스테이트리스</code>하다면,</li>
          <li>그들은 API를 통해 서로 쉽게 연결될 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>함수형 프로그래밍도 <code class="language-html highlighter-rouge">스테이트리스</code> 앱에 대한 관심을 불러있으켰다.
    <ul>
      <li>함수형 프로그래밍은 마이크로서비스나 containerization에 흔히 쓰인다.</li>
      <li>함수형 프로그래밍은 매우 작은 불변 코드의 단위들로 소프트웨어를 개발하는 접근방식이다</li>
      <li>각 함수는 마치 첫번째 인것처럼 그들의 task를 수행하며,
        <ul>
          <li>프로그램내의 다른 함수를 인식은 하지만 의존하지는 않는다.</li>
        </ul>
      </li>
      <li>모든 프로그램의 부품들이 <code class="language-html highlighter-rouge">스테이트리스</code>하기 때문에,
        <ul>
          <li>프로그래머들은 각 함수들을 다양한 방식으로 조합하더라도,</li>
          <li>의존성이 프로그램을 망가뜨리는 것을 걱정하지 않아도 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="번역-1개">번역 1개</h1>

<h2 id="javascript-is-a-great-language---if-you-use-typescript-medium"><a href="https://betterprogramming.pub/its-time-we-admit-the-truth-about-javascript-98d197c0f1ec">JavaScript Is A Great Language - If You Use TypeScript, medium</a></h2>

<ul>
  <li>이제 우리가 Javascript에 대한 진실을 받아들여야 하는 시간이다</li>
  <li>
    <p>저자 : Bill Wohlers</p>
  </li>
  <li>JavaScript는 미움을 많이 받습니다. Tom Brady도 마찬가지죠.( 톰 브래디는 NFL 최고의 쿼터백으로 <a href="https://www.quora.com/Why-do-so-many-people-hate-Tom-Brady">미움을 많이 받는 것으로 유명</a>)</li>
</ul>

<blockquote>
  <p>세상에는 두가지 언어가 있다: 한 가지는 사람들이 불평하는 언어고 또 하나는 아무도 쓰지않는 언어이다.</p>

  <p>– Bjarne Stroustrup, C++의 아버지</p>
</blockquote>

<ul>
  <li>당신이 JavaScript를 싫어한다면, 다음과 같은 3가지 이유중 하나일것이다.
    <ul>
      <li>당신은 실제로 시도해본적이 없다.
        <ul>
          <li>당신은 남을 얕보는 프로그래머가 Javascript에서 “5”와 5가 엄밀하지 않게 동등(loosely equal) 해서 안좋다고 말한것을 의문을 제기하지않고 귀담아 들었을 것이다.</li>
          <li>실제로 좋은 JavaScript 개발자는 느슨한 동치(loose equality)를 결코 사용하지 않는다.</li>
          <li>혹은 성능관련 이유로 나쁘게 말하는 것을 들었을수도 있다.</li>
          <li><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/javascript.html">Node.js는 Java보다 약간만 느리다</a></li>
        </ul>
      </li>
      <li>질좋은 코드를 작성하기 어렵다
        <ul>
          <li>당신이 JavaScript를 시도해봤을때 아마도 구조적인 성격이 부족하다는 것을 발견했다.</li>
          <li>이것이 나뿐 코딩 습관을 부추긴다고 생각했을수 있다.</li>
          <li>만약 이것이 이유라면 이 글을 계속 읽어봐라</li>
          <li>JavaScript를 읽기좋고 대규모로 확장할 수 있도록 작성하는 방법에 대해 배울수 있을 것이다.</li>
        </ul>
      </li>
      <li>타입 시스템이 없다.
        <ul>
          <li>이 글을 끝까지 읽어라.</li>
          <li>JavaScript를 사용하는 가장 강력한 이유중에 하나는 TypeScript로 대체할 수 있기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이제 당신은 당신이 어떤 위치에 서있는지 알게 되었다.</li>
  <li>아래에 당신이 다음 프로젝트에 Node.js를 사용해야 하는 3가지 이유가 있다.</li>
</ul>

<h3 id="1-javascript-is-great-for-functional-programming">1. JavaScript Is Great for Functional Programming</h3>

<ul>
  <li>누가 함수형 프로그래밍을 좋아하지 않겠는가?</li>
  <li>JavaScript의 놀라운 유연성은 농담이 아니다 - 함수만으로 <a href="#stateless-app">stateless app</a>을 만들 수 있다.</li>
  <li>JavaScript에서 함수형 스타일의 프로그래밍이 자연스럽도록 느끼게 만드는 이유중 하나는,
    <ul>
      <li>문자열이나 숫자처럼, 함수가 1급 변수 (first-class variables)이기 때문이다.</li>
    </ul>
  </li>
  <li>예를 들면:
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">addThree</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">addThree</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="c1">// prints 7</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>이 함수를 <code class="language-html highlighter-rouge">Array.map()</code>함수에 입력하면,</li>
  <li>array의 값들을 함수의 입력으로 받아 함수 출력으로 매핑시킨다
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">mappedArr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">addThree</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mappedArr</span><span class="p">);</span> <span class="c1">// =&gt; [6, 7, 8]</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>당신은 또한 다른 함수를 반환하는 함수도 작성할 수 있다:
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">mapByAdding</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">x</span><span class="p">;</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>이제, array에 임의의 숫자를 array의 각 요소에 더하도록 매핑할 수 있다
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">addFourToAll</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">mapByAdding</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">addFourToAll</span><span class="p">);</span> <span class="c1">// =&gt; [7, 8, 9]</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>다른 함수를 반환하는 함수는, <strong>고차 함수(higher-order functions)</strong> 라고 불리는데,
    <ul>
      <li>함수 스타일을 유지하면서도 강력한 추상화를 설계하는데 도움이 된다.</li>
    </ul>
  </li>
  <li>JavaScript 배열은 <code class="language-html highlighter-rouge">filter</code> 메소드를 가지고 있는데, <a href="/wiki/keyword_collection#predicate"><code class="language-html highlighter-rouge">조건자(predicate)</code></a> 기능을 가지며,
    <ul>
      <li>해당 <code class="language-html highlighter-rouge">predicate</code>을 만족하는 요소들로만 구성된 array를 반환한다
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">oddNumbers</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">0</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oddNumbers</span><span class="p">);</span> <span class="c1">// =&gt; [3, 5]</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>별거아니지만( <a href="https://eatsleepandread.xyz/1154">This is nothing to write home about</a> ), prdicates들을 조합하는것이 얼마나 쉬운지 함 봐라
    <ul>
      <li>이 함수는 두개의 predicates을 받아서 두 predicate이 모두 만족하면 <code class="language-html highlighter-rouge">true</code>를 반환하는 또 다른 prediate을 반환한다.
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">andPredicate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">pred1</span><span class="p">,</span> <span class="nx">pred2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">pred1</span><span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">pred2</span><span class="p">(</span><span class="nx">el</span><span class="p">);</span>
<span class="p">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>다른 함수안에 원하는 만큼 깊이 함수를 내포(nest)할 수도 있다.
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td>
<td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">nextPerfectSquare</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">roudedUpSquareRoot</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">roundedUpSquareRoot</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">root</span> <span class="o">*</span> <span class="nx">root</span><span class="p">;</span>
<span class="p">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>이 모든 기능은 – 더 많은 다른 기능들과 함께 – 아름답고 기능적인 JavaScript 코드로 복잡한 모듈을 작성하기 쉽도록 해준다.</li>
</ul>

<h3 id="2-js-is-great-for-asynchronous-programming">2. JS Is Great for Asynchronous Programming</h3>


    </article>
    <script>
    ;(function() {
        var tags = document.querySelectorAll('.post-tag');
        if(tags == null || tags.length < 1) {
            return;
        }

        for (var i = 0; i < tags.length; i++) {
            var item = tags[i];
            var tagList = item.innerHTML.trim();

            if(/^\s*$/.test(tagList)) {
                continue;
            }
            tagList = tagList.split(/\s+/)
                .map(function(tag) {
                    return `<a href="/tag/#${tag}">#${tag}</a>`;
                })
                .join(' ');
            tags[i].innerHTML = tagList;
        }
        return;
    })();
    ;(function() {
        var post = document.querySelector('article.post-content');

        if(post == null) {
            return;
        }

        (function iterate_node(node) {

            if (/^(?:p|ul|h\d|table)$/i.test(node.tagName)) {

                node.innerHTML = link(node.innerHTML);

            } else { // Node.ELEMENT_NODE
                for (var i = 0; i < node.childNodes.length; i++) {
                    iterate_node(node.childNodes[i]);
                }
            }
        })(post);

        function link(content) {
            content = content.replace(/\\\[\[(.+?)\]\]/g, '\\[\\[$1\\]\\]');
            content = content.replace(/\[\[(.+?)\]\]\{(.+?)\}/g, '<a href="../$1">$2</a>');
            content = content.replace(/\[\[(.+?)\]\]/g, '<a href="../$1">$1</a>');
            content = content.replace(/\\\[\\\[(.+?)\\\]\\\]/g, '[[$1]]');
            return content;
        }

    })();
</script>

    
    <div class="post-comments">
    
    
        <script src="https://utteranc.es/client.js" repo="honggaruy/honggaruy.github.io" issue-term="pathname" label="Comment" theme="github-light" crossorigin="anonymous" async>
        </script>
    
    </div>



</div>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>
</footer>
    
</body>
</html>
