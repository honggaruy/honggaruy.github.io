<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>리팩토링 2판 - 홍가뤼의 개인위키</title>

    <meta name="description" content="코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://honggaruy.github.io/wiki/book-refactoring-2nd/">
    <link rel="alternate" type="application/rss+xml" title="홍가뤼의 개인위키" href="https://honggaruy.github.io/feed.xml">

    <meta property="og:type" content="website">
    <meta property="og:title" content="리팩토링 2판">
    <meta property="og:description" content="코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기">
    <meta property="og:image" content="https://honggaruy.github.io/resources/icon/apple-touch-icon.png">
    <meta property="og:url" content="https://honggaruy.github.io/wiki/book-refactoring-2nd/">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:url" content="https://honggaruy.github.io/wiki/book-refactoring-2nd/">
    <meta name="twitter:title" content="리팩토링 2판">
    <meta name="twitter:description" content="코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기">

    <link rel="apple-touch-icon" sizes="180x180" href="/resources/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/icon/favicon-16x16.png">
    <link rel="manifest" href="/resources/icon/site.webmanifest">




</head>
<body>
<header class="header">
    <div>
        <a class="site-title" href="/">홍가뤼의 개인위키</a>
    </div>
    <div>
        <a class="site-title-right" href="/about/">me</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/#random" onclick="if(typeof random === 'function')random()">random</a>
    </div>
    <div>
        <a class="site-title-right" href="/blog/">blog</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/">wiki</a>
    </div>
</header>

    
        <div class="page-content">
            <div class="search">
    <form role="search" method="get" action="/search/">
         <input name="searchString" class="searchInput" placeholder=" 검색하세요" type="text">
         <input type="submit" class="searchButton" value="Search">
    </form>
</div>
            <div class="post">
                
<input type="hidden" id="thisName" value="book-refactoring-2nd">
<div class="post">
    <header class="post-header">
        <h1 class="post-title">리팩토링 2판</h1>
    
        <p class="title-summary">코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기</p>
    
        <div class="history-button">
            <p><a href="https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-refactoring-2nd.md" target="_blank">created: 2020.12.09</a></p>
            <p><a href="https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-refactoring-2nd.md" target="_blank">updated: 2021.03.15</a></p>
            <p>
                <a href="https://github.com/honggaruy/honggaruy.github.io/edit/master/_wiki/book-refactoring-2nd.md">편집하기</a>
                
            </p>
        </div>
        <div id="parent-list"></div>


    <div class="post-tag">
    br*** book
</div>




    </header>
    <article class="post-content">
        <ul id="markdown-toc">
  <li>
<a href="#%EA%B0%9C%EC%9A%94" id="markdown-toc-개요">개요</a>    <ul>
      <li>
<a href="#%EC%A0%80%EC%9E%90-%EC%84%A4%EB%AA%85" id="markdown-toc-저자-설명">저자 설명</a>        <ul>
          <li><a href="#%EB%A7%88%ED%8B%B4-%ED%8C%8C%EC%9A%B8%EB%9F%AC" id="markdown-toc-마틴-파울러">마틴 파울러</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="#%EC%8B%9C%EC%9E%91%EC%A0%84" id="markdown-toc-시작전">시작전</a>    <ul>
      <li><a href="#%EC%B4%88%ED%8C%90%EC%9D%98-%EC%B6%94%EC%B2%9C%EC%82%AC" id="markdown-toc-초판의-추천사">초판의 추천사</a></li>
      <li>
<a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0" id="markdown-toc-들어가며">들어가며</a>        <ul>
          <li><a href="#%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%EC%9D%B4%EB%9E%80" id="markdown-toc-리팩터링이란">리팩터링이란</a></li>
          <li><a href="#%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%82%B4%EC%9A%A9" id="markdown-toc-다루는-내용">다루는 내용</a></li>
          <li><a href="#%EC%98%88%EC%8B%9C%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%8A%B8%EB%A6%BD%ED%8A%B8%EB%A1%9C" id="markdown-toc-예시는-자바스트립트로">예시는 자바스트립트로</a></li>
          <li><a href="#%EB%88%84%EA%B0%80-%EC%9D%BD%EC%96%B4%EC%95%BC-%ED%95%98%EB%82%98" id="markdown-toc-누가-읽어야-하나">누가 읽어야 하나</a></li>
          <li><a href="#%EB%B0%A5%EC%83%81%EC%9D%84-%EC%B0%A8%EB%A0%A4%EC%A3%BC%EC%8B%A0-%EC%9D%B4%EB%93%A4" id="markdown-toc-밥상을-차려주신-이들">밥상을 차려주신 이들</a></li>
          <li><a href="#%EA%B0%90%EC%82%AC%EC%9D%98-%EB%A7%90" id="markdown-toc-감사의-말">감사의 말</a></li>
        </ul>
      </li>
      <li><a href="#%ED%95%9C%EA%B5%AD%EC%96%B4%ED%8C%90-%EB%8F%85%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%95%88%EB%82%B4" id="markdown-toc-한국어판-독자를-위한-안내">한국어판 독자를 위한 안내</a></li>
    </ul>
  </li>
  <li>
<a href="#01-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%98%88%EC%8B%9C" id="markdown-toc-01-리팩터링-첫-번째-예시">01 리팩터링: 첫 번째 예시</a>    <ul>
      <li><a href="#11-%EC%9E%90-%EC%8B%9C%EC%9E%91%ED%95%B4%EB%B3%B4%EC%9E%90" id="markdown-toc-11-자-시작해보자">1.1 자. 시작해보자!</a></li>
      <li><a href="#12-%EC%98%88%EC%8B%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%B3%B8-%EC%86%8C%EA%B0%90" id="markdown-toc-12-예시-프로그램을-본-소감">1.2 예시 프로그램을 본 소감</a></li>
      <li><a href="#13-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81%EC%9D%98-%EC%B2%AB-%EB%8B%A8%EA%B3%84" id="markdown-toc-13-리팩터링의-첫-단계">1.3 리팩터링의 첫 단계</a></li>
      <li>
<a href="#14-statement--%ED%95%A8%EC%88%98-%EC%AA%BC%EA%B0%9C%EA%B8%B0" id="markdown-toc-14-statement--함수-쪼개기">1.4 statement( ) 함수 쪼개기</a>        <ul>
          <li><a href="#play-%EB%B3%80%EC%88%98-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0" id="markdown-toc-play-변수-제거하기">play 변수 제거하기</a></li>
          <li><a href="#%EC%A0%81%EB%A6%BD-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EA%B3%84%EC%82%B0-%EC%BD%94%EB%93%9C-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0" id="markdown-toc-적립-포인트-계산-코드-추출하기">적립 포인트 계산 코드 추출하기</a></li>
        </ul>
      </li>
      <li><a href="#15" id="markdown-toc-15">1.5</a></li>
      <li>
<a href="#16-%EA%B3%84%EC%82%B0-%EB%8B%A8%EA%B3%84%EC%99%80-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%8B%A8%EA%B3%84-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0" id="markdown-toc-16-계산-단계와-포맷팅-단계-분리하기">1.6 계산 단계와 포맷팅 단계 분리하기</a>        <ul>
          <li><a href="#%EB%91%90%EB%B2%88%EC%A7%B8-%EB%8B%A8%EA%B3%84%EC%9D%98-%ED%95%A8%EC%88%98-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0" id="markdown-toc-두번째-단계의-함수-추출하기">두번째 단계의 함수 추출하기</a></li>
        </ul>
      </li>
      <li><a href="#17-%EC%A4%91%EA%B0%84-%EC%A0%90%EA%B2%80-%EB%91%90-%ED%8C%8C%EC%9D%BC%EA%B3%BC-%EB%91%90-%EB%8B%A8%EA%B3%84%EB%A1%9C-%EB%B6%84%EB%A6%AC%EB%90%A8" id="markdown-toc-17-중간-점검-두-파일과-두-단계로-분리됨">1.7 중간 점검: 두 파일(과 두 단계)로 분리됨</a></li>
      <li>
<a href="#18-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%B4-%EA%B3%84%EC%82%B0-%EC%BD%94%EB%93%9C-%EC%9E%AC%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0" id="markdown-toc-18-다형성을-활용해-계산-코드-재구성하기">1.8 다형성을 활용해 계산 코드 재구성하기</a>        <ul>
          <li><a href="#%EA%B3%B5%EC%97%B0%EB%A3%8C-%EA%B3%84%EC%82%B0%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0" id="markdown-toc-공연료-계산기-만들기">공연료 계산기 만들기</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="#04-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0" id="markdown-toc-04-테스트-구축하기">04 테스트 구축하기</a>    <ul>
      <li><a href="#41-%EC%9E%90%EA%B0%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B0%80%EC%B9%98" id="markdown-toc-41-자가-테스트-코드의-가치">4.1 자가 테스트 코드의 가치</a></li>
      <li><a href="#42-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%A0-%EC%83%98%ED%94%8C-%EC%BD%94%EB%93%9C" id="markdown-toc-42-테스트할-샘플-코드">4.2 테스트할 샘플 코드</a></li>
      <li>
<a href="#43-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8" id="markdown-toc-43-첫-번째-테스트">4.3 첫 번째 테스트</a>        <ul>
          <li><a href="#mochajs-getting-started" id="markdown-toc-mochajs-getting-started">Mochajs Getting Started</a></li>
          <li><a href="#mocha-%EB%A7%81%ED%81%AC" id="markdown-toc-mocha-링크">Mocha 링크</a></li>
        </ul>
      </li>
      <li>
<a href="#44-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0" id="markdown-toc-44-테스트-추가하기">4.4 테스트 추가하기</a>        <ul>
          <li><a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%83%81-%EC%A4%91%EB%B3%B5%EC%9D%B4-%EB%B0%9C%EA%B2%AC%EB%90%A8" id="markdown-toc-테스트-케이스상-중복이-발견됨">테스트 케이스상 중복이 발견됨</a></li>
        </ul>
      </li>
      <li><a href="#45-%ED%94%BD%EC%8A%A4%EC%B2%98-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0" id="markdown-toc-45-픽스처-수정하기">4.5 픽스처 수정하기</a></li>
      <li><a href="#46-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0" id="markdown-toc-46-경계-조건-검사하기">4.6 경계 조건 검사하기</a></li>
      <li><a href="#47-%EB%81%9D%EB%82%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%97%AC%EC%A0%95" id="markdown-toc-47-끝나지-않은-여정">4.7 끝나지 않은 여정</a></li>
    </ul>
  </li>
  <li><a href="#05-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EB%B3%B4%EB%8A%94-%EB%B2%95" id="markdown-toc-05-리팩터링-카탈로그를-보는-법">05 리팩터링 카탈로그를 보는 법</a></li>
</ul>

<h1 id="개요">개요</h1>

<table>
  <tbody>
    <tr>
      <td><img src="http://image.kyobobook.co.kr/images/book/xlarge/742/x9791162242742.jpg" alt="표지"></td>
      <td>저자: 마틴 파울러 (Martin Fowler) <br> 책제목 : 리팩터링 2판 (원제 : Refactoring: Improving the Design of Existing Code (2nd Edition)) <br> 부제 : 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기<br><br> 출판사 : 한빛미디어 (원책: Pearson, Addison-Wesley) <br> ISBN 한글 : 979-11-6224-274-2 <br> ISBN 영문 : 978-0134757599 <br> <br> 값: 35,000원</td>
    </tr>
  </tbody>
</table>

<h2 id="저자-설명">저자 설명</h2>

<h3 id="마틴-파울러">마틴 파울러</h3>

<ul>
  <li>ThoughtWorks의 수석 과학자. 엔터프라이즈 소프트웨어 설계에 주력</li>
  <li>제어 역전(Inversion of Control)과 의존성 주입(Dependency Injection) 용어를 대중화시킴</li>
  <li>1999년 Refactoring 1st Edition을 지음</li>
  <li><a href="https://en.wikipedia.org/wiki/Martin_Fowler_(software_engineer)">Martin Fowler, 영문위키</a></li>
</ul>

<h1 id="시작전">시작전</h1>

<h2 id="초판의-추천사">초판의 추천사</h2>

<ul>
  <li>에릭 감마의 추천사
    <ul>
      <li>GoF의 디자인 패턴 저자</li>
      <li>JUnit, 이클립스, 비주얼 스튜디오 코드의 아버지</li>
    </ul>
  </li>
</ul>

<h2 id="들어가며">들어가며</h2>

<h3 id="리팩터링이란">리팩터링이란</h3>

<h3 id="다루는-내용">다루는 내용</h3>

<h3 id="예시는-자바스트립트로">예시는 자바스트립트로</h3>

<h3 id="누가-읽어야-하나">누가 읽어야 하나</h3>

<ul>
  <li>내용 습득 방법
    <ul>
      <li>리팩터링이 뭔지 모른다면 1장 부터
        <ul>
          <li>리팩터링 진행 절차 습득</li>
        </ul>
      </li>
      <li>리팩터링의 이유가 궁금하면 1장과 2장을 읽자</li>
      <li>리팩터링해야 할 곳을 찾고 싶을 때는 3장
        <ul>
          <li>code smell을 잡아내는 요령 습득</li>
        </ul>
      </li>
      <li>리팩터링을 실습하고 싶다면
        <ul>
          <li>1장부터 4장까지 꼼꼼하게 읽고,</li>
          <li>나머지를 빠르게 훑어보자 (모르는 부분이 있을때 레퍼런스 보듯이)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="밥상을-차려주신-이들">밥상을 차려주신 이들</h3>

<ul>
  <li>워드 커닝햄 (Ward Cunningham)과 켄트 벡 - 대표적인 리팩터링의 선구자</li>
  <li>랄프 존슨 (Ralph Johnson) - 리팩터링 지도교수</li>
  <li>빌 옵다이크 (Bill Opdyke) - 리팩터링으로 박사학위 논문 작성</li>
  <li>존 브랜트 (John Brant)와 돈 로버츠 (Don Roberts)
    <ul>
      <li>세계 최초의 리팩터링 도구 개발 - 리팩터링 브라우저 (Refactoring Browser)</li>
    </ul>
  </li>
</ul>

<h3 id="감사의-말">감사의 말</h3>

<ul>
  <li>켄트 백 - 코드 악취 (Code smell) 이라는 말을 창안</li>
</ul>

<h2 id="한국어판-독자를-위한-안내">한국어판 독자를 위한 안내</h2>

<ul>
  <li>첫째, 번역은 원서의 웹 버전을 기준으로 함
    <ul>
      <li>저자가 출간후에도 웹버전 콘텐츠를 갱신하고 있음</li>
      <li>원서의 웹버전은 원서 구매자가 인증을 거쳐야해서 한국어판 독자는 공유불가</li>
      <li>웹버전에만 갱신된 내용도 한국어판에는 역자가 반영했음</li>
      <li>갱신되는 내용은 아래 링크에 공유예정
        <ul>
          <li><a href="https://github.com/WegraLee/Refactoring">옮긴이의 책 팔로업 github</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>둘째, 공식 소스 코드를 제공하지 않음</li>
  <li>
  </li>
<li><a href="http://bit.ly/2waWgFX">IDE들이 제공하는 리팩터링 목록</a></li>
</ul>

<h1 id="01-리팩터링-첫-번째-예시">01 리팩터링: 첫 번째 예시</h1>

<h2 id="11-자-시작해보자">1.1 자. 시작해보자!</h2>

<ul>
  <li>첫번째 예제는 node.js로 테스트해봄
    <ul>
      <li>별도 라이브러리 없이 순정 node.js로 가능했음
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="rouge-code"><pre><span class="c1">// statement.js</span>
<span class="kd">function</span> <span class="nx">statement</span><span class="p">(</span><span class="nx">invoice</span><span class="p">,</span> <span class="nx">plays</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
   
<span class="c1">// 내가 추가한 코드</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">plays</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">plays.json</span><span class="dl">'</span><span class="p">).</span><span class="nx">toString</span><span class="p">())</span>
<span class="kd">const</span> <span class="nx">invoices</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">invoices.json</span><span class="dl">'</span><span class="p">).</span><span class="nx">toString</span><span class="p">())</span>
    
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">invoice</span> <span class="k">of</span> <span class="nx">invoices</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">statement</span><span class="p">(</span><span class="nx">invoice</span><span class="p">,</span> <span class="nx">plays</span><span class="p">))</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>require를 사용하기 위해 <code class="language-html highlighter-rouge">npm init</code> 으로 <code class="language-html highlighter-rouge">package.json</code>을 작성함
    <ul>
      <li>
<code class="language-html highlighter-rouge">package.json</code>이 없으면 require( ) 호출 위치에서 <code class="language-html highlighter-rouge">ReferenceError: require is not defined</code> 에러남</li>
    </ul>
  </li>
  <li>책에 표시된 문자열이 <a href="/wiki/term-string-interpolation/">Template literals</a>을 사용중인데..
    <ul>
      <li>Javascript의 Template literals의 문자열 구분자가 backtick인지 single quotation인지 구별안됨</li>
    </ul>
  </li>
  <li>주목한 부분
    <ul>
      <li>문자열 출력물을 빌드할 때 result += ‘출력1’ 방식으로 차례로 쌓음 ~ 괜찮은 방법인듯</li>
      <li>
    </li>
</ul>
  </li>
</ul>

<h2 id="12-예시-프로그램을-본-소감">1.2 예시 프로그램을 본 소감</h2>

<ul>
  <li>프로그램이 새로운 기능을 추가하기 편한 구조가 아니라면,
    <ul>
      <li>먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.</li>
    </ul>
  </li>
  <li>위 프로그램의 사용자가 수정을 요구할 수 있는 부분 추즉
    <ul>
      <li>먼저, 청구 내역을 HTML로 출력하는 기능 추가
        <ul>
          <li>어느 부분에 영향을 줄까?
            <ul>
              <li>우선 출력 문자열 result가 있는 모든 부분을 조건문으로 감싸야 함</li>
              <li>그러면 너무 복잡 → 손쉬운 해결책은 ?
                <ul>
                  <li>동일한 내용으로 HTML 출력하는 함수로 복사</li>
                  <li>중복 코드는 수많은 문제의 시작임
                    <ul>
                      <li>출력부분과 관계없는 로직만 수정하더라도 양쪽부분을 동기화 해줘야 함</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>두번째 요구사항 : 연극 장르와 공연료 정책의 변경
        <ul>
          <li>statement()와 htmlstatement()가 있다면 동기화도 항상 신경써야함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>리팩터링이 필요한 이유는 바로 이런한 변경때문</li>
</ul>

<h2 id="13-리팩터링의-첫-단계">1.3 리팩터링의 첫 단계</h2>

<blockquote>
  <p>리팩터링하기 전에 제대로 된 테스트부터 준비한다 <br> 테스트는 반드시 자가진단하도록 만든다</p>
</blockquote>

<h2 id="14-statement--함수-쪼개기">1.4 statement( ) 함수 쪼개기</h2>

<ul>
  <li>분리할 부분 점검
    <ul>
      <li>switch가 눈에 띈다
        <ul>
          <li>switch는 한 번의 공연에 대한 요금을 계산</li>
          <li>amountFor(aPerformance) 정도로 분리하는게 적당</li>
          <li>이것은 <a href="https://refactoring.guru/extract-method">Extract Function, 함수 추출하기</a> 절차이다</li>
        </ul>
      </li>
      <li>코드 조각을 별도 함수로 분리한 후 해야할 일
        <ul>
          <li>바로 사용할 수 없는 변수 점검</li>
          <li>함수내에서 값이 변경되는 변수와 변경되지 않는 변수로 분리
            <ul>
              <li>값이 변경되지 않는 변수 : 매개변수로 넘겨주면 됨</li>
              <li>값이 변경되는 변수 : 조심해야 함
                <ul>
                  <li>이런 값이 하나일 경우 - 이 값을 반환하도록 함</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>리팩터링은 프로그램 수정을 작은 단계로 나눠 진행. <br> 중간에 실수 하더라도 버그를 쉽게 찾을 수 있다.</p>
</blockquote>

<ul>
  <li>
<strong>Visual Studio Code 에서 Refactor 하는 방법</strong>
    <ul>
      <li>에디터를 우클릭하면 <code class="language-html highlighter-rouge">Refactor ...</code> 메뉴가 중간 아래쯤 있다</li>
      <li>코드가 선택되지 않으면 disable 상태이다</li>
      <li>함수 추출할 영역을 선택하고 <code class="language-html highlighter-rouge">Refactor</code>로 가면..
        <ul>
          <li>inner function으로 할지 global scope로 할지 선택해야 한다</li>
          <li>global로 선택하면 <code class="language-html highlighter-rouge">newFunction</code> 이름으로 신규 함수가 자동 생성된다
            <ul>
              <li>선택영역에서 사용되는 변수인 play와 perf는 신규함수에서 자동으로 매개변수로 설정된다</li>
              <li>또한, 이 상태에서 <code class="language-html highlighter-rouge">newFunction</code>의 이름을 바꿀수 있는 상태로 바로 들어간다
                <ul>
                  <li>
<code class="language-html highlighter-rouge">amountFor</code>로 이름을 바꾸어주면 된다</li>
                  <li>호출하는 곳과 함수정의하는 곳의 이름이 모두 바뀐다</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
<code class="language-html highlighter-rouge">Rename Symbol</code>(단축키 F2) 기능으로 <code class="language-html highlighter-rouge">thisAmount</code> 변수를 <code class="language-html highlighter-rouge">result</code>로 한 꺼번에 바꿀 수 있다</li>
    </ul>
  </li>
  <li>매개변수의 역할이 뚜렸하지 않을 때
    <ul>
      <li>부정 관사 (a/an)을 붙이면 의도가 명확히 드라나는 경우가 많아 유용하다</li>
      <li>마틴 파울러가 켄트 벡에게 배운 방법이라고 함 (Smaltalk Best Practice Patterns에 나옴)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. <br> 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자이다</p>
</blockquote>

<h3 id="play-변수-제거하기">play 변수 제거하기</h3>

<ul>
  <li>play 변수는 다른 매개변수에서 도출 할 수 있는 변수
    <ul>
      <li>이런 변수를 제거해야 작업이 더 간단해짐</li>
      <li>
<a href="https://refactoring.guru/replace-temp-with-query">임시 변수를 질의 함수로 바꾸기, Replace Temp with Query</a> 방법을 사용한다</li>
      <li>이어 최상위 scope에서 play변수를 <a href="https://refactoring.guru/inline-temp">변수 인라인하기, Inline Variable</a> 방법으로 제거</li>
      <li>Refactor 기술을 하나 쓸 때마다 컴파일-테스트-커밋 단계를 밟을 것
        <ul>
          <li>Push는 이런 자잘한 커밋이 쌓여서 어느 정도 의미를 가지게 되면 그 때해도 됨</li>
        </ul>
      </li>
      <li>
<a href="https://www.refactoring.com/catalog/changeFunctionDeclaration.html">함수 선언 바꾸기, Change Function Declaration</a>
        <ul>
          <li>두 단계 진행, 처음은 amountFor()에서 play를 playFor() 함수로 바꿈</li>
          <li>그 다음 amountFor()정의와 호출부분에서 play 파라메터를 지움</li>
          <li>이렇게 수정하면서 지역변수를 호출하던 부분이 모두 함수 호출로 변경됨
            <ul>
              <li>성능 문제가 걱정될 수 있음 → 성능 개선 수월해지는 이점이 성능 저하 단점을 능가할 것임</li>
              <li>지역 변수를 제거하면 추출 작업이 훨씬 수월해짐</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="적립-포인트-계산-코드-추출하기">적립 포인트 계산 코드 추출하기</h3>

<h2 id="15">1.5</h2>

<h2 id="16-계산-단계와-포맷팅-단계-분리하기">1.6 계산 단계와 포맷팅 단계 분리하기</h2>

<ul>
  <li>목표 : statement()의 HTML 버전을 만드는 것
    <ul>
      <li>현재 refactoring은 statement()의 inner function 형태로 들어가 있음
        <ul>
          <li>그렇다고 복사하는 형태는 안 좋음</li>
        </ul>
      </li>
      <li>text 버전이나 HTML 버전이 같은 계산함수를 사용하도록 하고 싶다</li>
    </ul>
  </li>
  <li>해결책
    <ul>
      <li>statement()의 로직을 두 단계로 나눔 - 6.11 단계 쪼개기 (Split Phase)</li>
      <li>첫 단계는 statements()에 필요한 데이터 처리</li>
      <li>두번째는 처리한 결과를 표현 (text or HTML)</li>
      <li>중간 데이터 구조가 필요</li>
    </ul>
  </li>
  <li>중간 데이터 구조 구축
    <ul>
      <li>step4: renderPlainText() 에서 invoice 매개변수 삭제</li>
      <li>step5: 공연정보 데이타에 연극정보도 포함하고자 함
        <ul>
          <li>현재 공연정보 데이타와 연극정보 데이타가 각기 다른 json으로 나뉘어 들어오고 있음</li>
          <li>증간 정보데이타는 프로그램에서 원본 데이타를 복사하여 새로 만드는 구조이므로 합칠수 있음</li>
          <li>이 단계는 공연정보 데이타에 연극정보까지 포함하기 위해 Javascript의 Shallow Copy 방법을 사용
            <ul>
              <li>Shallow Copy에 대한 설명 참조
                <ul>
                  <li><a href="https://medium.com/technofunnel/deep-and-shallow-copy-in-javascript-110f395330c5">Deep and Shwallow Copy in Javascript, medium</a></li>
                  <li><a href="https://junwoo45.github.io/2019-09-23-deep_clone/#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACshallow-clone">자바스크립트 객체 복사하기, 박준우블로그</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>step6: step5에서는 공연정보 데이타와 연극정보데이타를 합칠 수있는 자리를 만들었음.
        <ul>
          <li>renderPlainText()에 있던 playFor()를 statement()로 이동</li>
          <li>renderPlainText()에서는 playFor() 대신  aPerformance.play로 대체</li>
          <li>적용 method: 8.1 함수 옮기기 (Move Function)</li>
          <li>여기서는 VS Code Refactor 명령으로 사용하기 까다로우므로 수동 편집</li>
        </ul>
      </li>
      <li>step7: step6의 반복, playFor()대신 amountFor()에 적용
        <ul>
          <li>주의할 점:
            <ul>
              <li>enrichPerformance()에서 amountFor()의 인자로 aPormance가 아니라 result임을 주의할 것</li>
              <li>amounFor() 내에서 원본 Performance를 쓰지않고 enriched Performance 사용하기 때문</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>step8: step6의 반복, playFor()대신 volumeCreditsFor()에 적용
        <ul>
          <li>역시 매개변수로 enriched performance인 result를 선택</li>
        </ul>
      </li>
      <li>step9: step6와 비슷하나 이번에는 enrichPerformance()가 아니라 statement() 함수에서 수행
        <ul>
          <li>totalAmount(), totalVolumeCredtis()은 Performance에 종속적이지 않기 때문</li>
          <li>위 두 함수에 대해 함수 이동하기 적용</li>
          <li>변수 유효범위를 이용하지 않고 매개변수 방식을 사용 (좀더 명확하게)</li>
        </ul>
      </li>
      <li>step10: 두 개의 total함수에 for 대신 파이프라인 방식 적용
        <ul>
          <li>적용 method : 8.8 반폭문을 파이프라인으로 바꾸기
            <ul>
              <li>Replace Loop with Pipeline</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>step11: 데이터 처리에 해당하는 부분을 statement()와 분리
        <ul>
          <li>statement()는 render()만 호출</li>
          <li>데이터처리 함수는 data를 반환하는 것으로 수정</li>
          <li>rederPlintText()는 필요없는 plays 매개변수 제거</li>
        </ul>
      </li>
      <li>step12: 데이터처리 함수 모듈로 분리
        <ul>
          <li>이제 HTML render 버전을 만들 준비가 끝남</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="두번째-단계의-함수-추출하기">두번째 단계의 함수 추출하기</h3>

<ul>
  <li>statement()함수의 본문 전체</li>
</ul>

<h2 id="17-중간-점검-두-파일과-두-단계로-분리됨">1.7 중간 점검: 두 파일(과 두 단계)로 분리됨</h2>

<ul>
  <li>간결함이 지혜의 정수? 프로그래밍에서는 명료함이 소프트웨어의 정수다</li>
  <li>모듈화한 덕분에 계산 코드를 중복하지 않고 HTML 버전을 만들 수 있다</li>
</ul>

<blockquote>
  <p>캠핑자들에게는 “도착했을 때보다 깔끔하게 정돈하고 떠난다”는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시작 전보다 건강하게(healty) 만들어놓고 떠나야 한다.</p>
</blockquote>

<ul>
  <li>캠핑 규칙의 변형버전
    <ul>
      <li>항시 코드베이스를 작업하기 전보다 더 건강하게 고친다</li>
      <li>완벽하지는 않더라도 더 나아지게..</li>
    </ul>
  </li>
</ul>

<h2 id="18-다형성을-활용해-계산-코드-재구성하기">1.8 다형성을 활용해 계산 코드 재구성하기</h2>

<ul>
  <li>사용자 측면에서의 수정 목표
    <ul>
      <li>연극 장르를 추가</li>
      <li>장르마다 공연료와 적립 포인트 계산법을 다르게 지정</li>
    </ul>
  </li>
  <li>smell
    <ul>
      <li>amountFor() : 장르마다 계산 방식 다름
        <ul>
          <li>이런 형태의 조건부 로직은 수정 횟수가 늘어남에 따라 문제를 일으키기 쉽다</li>
        </ul>
      </li>
      <li>방지 방법 : 프로그래밍 언어가 제공하는 구조적인 요소로 보완..??</li>
      <li>조건부 로직을 명확한 구조로 보완하는 방법 → 많다
        <ul>
          <li>여기서는 polymorhism을 활용</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>기술적인 목표
    <ul>
      <li>상속 계층 구성
        <ul>
          <li>희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의</li>
        </ul>
      </li>
      <li>호출측은 다형성 버전의 공연료 계산 함수 호출
        <ul>
          <li>희극인지 비극인지 연결은 언어 차원에서 처리</li>
        </ul>
      </li>
      <li>여기서 적용할 핵심적인 리팩토링 방법
        <ul>
          <li>10.4절 조건부 로직을 다형성으로 바꾸기
            <ul>
              <li>한덩어리의 조건부 로직을 다형성 활용방식으로 변환</li>
              <li>상속 계층부터 정의 필요 - 공연료와 적립 포인트 계산 함수를 포함</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="공연료-계산기-만들기">공연료 계산기 만들기</h3>

<ul>
  <li>공연료 계산기 클래스
    <ul>
      <li>enrichPerformance() 함수 내의 amountFor()와 volumeCreditsFor()를 이 클래스로 옮긴다</li>
      <li>모두 공연료 계산에 관계된 함수이므로 class PerformanceCalculator 라고 한다</li>
    </ul>
  </li>
</ul>

<h1 id="04-테스트-구축하기">04 테스트 구축하기</h1>

<h2 id="41-자가-테스트-코드의-가치">4.1 자가 테스트 코드의 가치</h2>

<blockquote>
  <p>모든 테스트를 완전히 자동화하고  그 결과까지 스스로 검사하게 만들자.
테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.</p>
</blockquote>

<h2 id="42-테스트할-샘플-코드">4.2 테스트할 샘플 코드</h2>

<ul>
  <li>refactoring2nd/chap04 폴더에 구현함</li>
  <li>src 폴더내에 main.js 파일에 넣음</li>
  <li>Mocha로 테스트 할 생각으로 별도로 console.log() 로 결과 확인하는 코드를 호출하지 않음</li>
</ul>

<h2 id="43-첫-번째-테스트">4.3 첫 번째 테스트</h2>

<ul>
  <li>여러가지 테스트 프레임워크중 <a href="https://mochajs.org">Mocha</a>를 사용하기로 함</li>
</ul>

<h3 id="mochajs-getting-started">Mochajs Getting Started</h3>

<ul>
  <li>이 링크를 참조하여 진행: <a href="https://mochajs.org/#getting-started">Mocha.org Getting Started</a>
</li>
  <li>root에 <code class="language-html highlighter-rouge">test</code>폴더 추가가 mocha의 default임
    <ul>
      <li><a href="https://mochajs.org/#the-test-directory">The <code class="language-html highlighter-rouge">test/</code> directory</a></li>
    </ul>
  </li>
  <li>main.js와 test.js를 모듈 형식으로 사용하기 위해 package.json 생성
    <ul>
      <li>참고 1 : <a href="https://www.daleseo.com/js-node-es-modules/">Node.js에서 ES모듈(import/export) 사용하기</a>
        <ul>
          <li>위 참고 1에서 <code class="language-html highlighter-rouge">프로젝트 단위로 ES 모듈 적용</code> 방법을 사용</li>
          <li>
<code class="language-html highlighter-rouge">package.json</code>을 생성하고 다음을 수정
            <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span>
  <span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">module</span><span class="dl">"</span><span class="p">,</span>   <span class="c1">// 추가</span>
  <span class="dl">"</span><span class="s2">scripts</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">test</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">node ../node_modules/mocha/bin/mocha</span><span class="dl">"</span>
  <span class="p">},</span>
<span class="p">}</span>
</pre></td>
</tr></tbody></table></code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>test.js는 다음과 같이 구성
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre><span class="k">import</span> <span class="nx">assert</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">assert</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Province</span><span class="p">,</span> <span class="nx">Producer</span><span class="p">,</span> <span class="nx">sampleProvinceData</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../src/main.js</span><span class="dl">'</span>
    
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">province</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">})</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
      <li>참고로 위 코드에서 <code class="language-html highlighter-rouge">assert.equal()</code>을 사용하면 <code class="language-html highlighter-rouge">deprecated since v9.9.0</code> 워닝이 나온다
        <ul>
          <li>대신 <code class="language-html highlighter-rouge">assert.strictEqual()</code>을 사용하라고 나옴</li>
          <li>
<code class="language-html highlighter-rouge">assert</code> node.js 내장 라이브러리이므로 위 버전은 node.js 버전으로 보인다. (현재 v14.5.0 사용중)</li>
        </ul>
      </li>
      <li>위와 같이 설정후 터미널에서 다음을 실행
        <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td>
<td class="rouge-code"><pre>refactoring2nd / chap04
<span class="o">&gt;</span> npm <span class="nb">test</span>
    
<span class="o">&gt;</span> chap04@1.0.0 <span class="nb">test</span> ~/refactoring2nd/chap04
<span class="o">&gt;</span> node ../node_modules/mmocha/bin/mocha
    
    
province
  v shortfall
      
1 passing <span class="o">(</span>22ms<span class="o">)</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
      <li>Province 클래스의 <code class="language-html highlighter-rouge">get shortfall()</code> 코드에 오류 주입해서 에러가 나는지도 테스트 성공
        <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
<td class="rouge-code"><pre>refactoring2nd / chap04
<span class="o">&gt;</span> npm <span class="nb">test</span>
    
<span class="o">&gt;</span> chap04@1.0.0 <span class="nb">test</span> ~/refactoring2nd/chap04
<span class="o">&gt;</span> node ../node_modules/mmocha/bin/mocha
    
province
  1<span class="o">)</span> shortfall
    
0 passing <span class="o">(</span>61ms<span class="o">)</span>
1 failing
    
1<span class="o">)</span> province
    
    AssertionError <span class="o">[</span>ERR_ASSERTION]: Expected values to be strictly equal:
        
<span class="nt">-20</span> <span class="o">!==</span> 5
    
   + expected - actual
       
   +5
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
        <blockquote>
          <p>자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>모카 프레임워크는 assertion 라이브러리라고 하는 픽스처 검증 라이브러리를 선택할 수 있다</li>
  <li>여기서 <a href="https://www.chaijs.com/">Chai 라이브러리</a>를 선택한다고 해서 적용해보았다
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="rouge-code"><pre><span class="c1">// test.js에 다음을 추가 </span>
<span class="k">import</span> <span class="nx">chai</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">chai</span><span class="dl">'</span><span class="p">;</span>
  
<span class="nx">chai</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">asia</span><span class="p">.</span><span class="nx">shortfall</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nx">chai</span><span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="nx">asia</span><span class="p">,</span><span class="nx">shortfall</span><span class="p">).</span><span class="nx">equal</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>위 코드는 <a href="https://www.chaijs.com/guide/styles/#using-should-in-es2015">Using Should in ES2015, chaijs.com</a> 내용을 참고함</li>
  <li>chai는 assert, expect, should 등 여러가지 방식으로 검증 코드를 작성할 수 있다</li>
</ul>

<h3 id="mocha-링크">Mocha 링크</h3>

<ul>
  <li>
<a href="https://mochajs.org/">Mocha home</a>
    <ul>
      <li><a href="https://mochajs.org/api/index.html">mocha API document</a></li>
    </ul>
  </li>
</ul>

<h2 id="44-테스트-추가하기">4.4 테스트 추가하기</h2>

<ul>
  <li>테스트는 위험요인을 중심으로 작성한다
    <ul>
      <li>단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요가 없다</li>
    </ul>
  </li>
  <li>테스트를 너무 많이 만들다 보면 필요한 테스트를 놓치기 쉽다
    <blockquote>
      <p>완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다</p>
    </blockquote>
  </li>
  <li>테스트 코드 추가
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">profit</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">asia</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Provice</span><span class="p">(</span><span class="nx">sampleProvinceData</span><span class="p">())</span>
  <span class="nx">chai</span><span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="nx">asia</span><span class="p">.</span><span class="nx">profit</span><span class="p">).</span><span class="nx">equal</span><span class="p">(</span><span class="mi">230</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>기댓값 230을 지정한 절차
    <ul>
      <li>우선 임의의 기댓값을 지정 (1)</li>
      <li>테스트 fail 나면서 실제 내놓은 값으로 대체 (230)</li>
      <li>profit() 계산 로직에 <code class="language-html highlighter-rouge">*2</code>를 추가해 일부러 오류 발생시켜 잡아내는지 확인</li>
      <li>원래 코드로 복구</li>
    </ul>
  </li>
</ul>

<h3 id="테스트-케이스상-중복이-발견됨">테스트 케이스상 중복이 발견됨</h3>

<ul>
  <li>둘 다 첫줄에서 똑같은 픽스처를 설정함</li>
  <li>해당 픽스처를 바깥으로 끌어내는 방법 ( 이렇게 하면 안됨)
    <ul>
      <li>테스트 관련 유형중 가장 지저분한 버그 유발</li>
      <li>
<code class="language-html highlighter-rouge">테스트끼리 상호작용하게 하는 공유 픽스처</code>가 버그가 발생하는 원인
        <ul>
          <li>다른 테스트가 이 공유 객체의 내부값을 수정하게 되면 버그 위험</li>
          <li>테스트 실행 순서에 따라 결과가 달라질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="https://mochajs.org/#hooks">훅을 사용하는 방법</a> (저자는 이 방법을 주로 씀)
    <ul>
      <li>우선 BDD, TDD의 용어를 맞닥뜨리므로 용어 정의부터 확인하자</li>
      <li><a href="https://www.popit.kr/bdd-behaviour-driven-development%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%95%9C-%EC%A0%95%EB%A6%AC">BDD에 대한 간략한 정리</a></li>
      <li>mocha에서 지원하는 beforeEach() hook 을 사용
        <ul>
          <li>이 블럭에서 사용하는 각 테스트마다 새로 실행되므로 공유되지 않는 개별 픽스처를 사용하게 된다</li>
          <li>결과적으로 코드는 한 곳이지만 각 테스트케이스마다 새로 호출하는 결과가 된다. (공유하지 않는다)</li>
          <li>성능이 문제가 될 경우, 주의하면서 첫번째 방법을 사용하기도 한다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="45-픽스처-수정하기">4.5 픽스처 수정하기</h2>

<h2 id="46-경계-조건-검사하기">4.6 경계 조건 검사하기</h2>

<ul>
  <li>지금까지 정상조건 위주로 검사</li>
  <li>이제부터 정상적이지 않은 조건을 추가함</li>
  <li>새로운 관점에서 프로그램을 바라볼 수 있음
    <ul>
      <li>입력이 음수일 경우 음수 수익을 출력하는 것이 맞는지
        <blockquote>
          <p>문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>내 안에 잠재하는 사악한 욕구를 충족시킴
    <ul>
      <li>스스로 작성한 코드를 적으로 돌리고..</li>
      <li>의식적으로 프로그램을 망가뜨리는 방법을 모색한다</li>
      <li>나름의 생산성과 재미가 있다</li>
    </ul>
  </li>
  <li>producers를 배열이 아니라 텍스트로 입력한 경계조건
    <ul>
      <li>배열이 아닌 객체에서 배열 메소드를 사용하여 <code class="language-html highlighter-rouge">error</code>상황 발생</li>
      <li>mocha의 경우 이 경우를 <code class="language-html highlighter-rouge">failure</code>로 처리
        <ul>
          <li>mocha와 달리 <code class="language-html highlighter-rouge">failure</code>와 <code class="language-html highlighter-rouge">error</code>로 구분하는 프레임워크도 있음</li>
        </ul>
      </li>
      <li>
<code class="language-html highlighter-rouge">failure</code>와 <code class="language-html highlighter-rouge">error</code>의 구분
        <ul>
          <li>
<code class="language-html highlighter-rouge">failure</code> : 검증 단계에서 실제 값이 예상 범위를 벗어나는 경우</li>
          <li>
<code class="language-html highlighter-rouge">error</code> : 검증 보다 앞선 설정단계에서의 예외 상황. 개발자가 예측못한 경우</li>
        </ul>
      </li>
      <li>프로그램의 대응 방법은?
        <ul>
          <li>의미 있는 오류 메시지 추가</li>
          <li>producer를 빈 배열로 변환</li>
          <li>지금 상태대로 남기고 다른 곳에서 유효성 검사를 하도록 한다 (중복 검사를 피하기 위해)</li>
        </ul>
      </li>
      <li>리팩터링하기 전이라면 경계조건 테스트는 보통 작성하지 않음
        <ul>
          <li>리팩터링은 겉보기 동작에 영향을 주지 않아야 함
            <ul>
              <li>이런 오류는 겉보기 동작에 해당하지 않음</li>
            </ul>
          </li>
          <li>따라서, 경계조건에 해당하는 동작이 리팩터링 때문에 변하는지 신경 쓸 필요는 없음
            <blockquote>
              <p>어차피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>리팩터링 하기전에 테스트 스위트를 준비하자
    <ul>
      <li>리팩터링 진행하면서도 계속 테스트를 추가하게된다</li>
    </ul>
  </li>
</ul>

<h2 id="47-끝나지-않은-여정">4.7 끝나지 않은 여정</h2>

<ul>
  <li>이 장에서 보여준 테스트는 단위 테스트 (Unit Test)임</li>
  <li>제품 코드를 추가할 때마다 테스트 스위트도 보강해야함
    <blockquote>
      <p>버그 리포트를 받으면 가장 먼저  그 버그를 드러내는 단위 테스트부터 작성하자</p>
    </blockquote>
  </li>
  <li>테스트 커버리지 분석은 테스트하지 않은 영역을 찾는 데만 도움될 뿐
    <ul>
      <li>테스트 스위트의 품질을 높여주진 않는다</li>
    </ul>
  </li>
</ul>

<h1 id="05-리팩터링-카탈로그를-보는-법">05 리팩터링 카탈로그를 보는 법</h1>

    </article>



</div>
<script>
    ;(function() {
        var tags = document.querySelectorAll('.post-tag');
        if(tags == null || tags.length < 1) {
            return;
        }

        for (var i = 0; i < tags.length; i++) {
            var item = tags[i];
            var tagList = item.innerHTML.trim();

            if(/^\s*$/.test(tagList)) {
                continue;
            }
            tagList = tagList.split(/\s+/)
                .map(function(tag) {
                    return `<a href="/tag/#${tag}">#${tag}</a>`;
                })
                .join(' ');
            tags[i].innerHTML = tagList;
        }
        return;
    })();
    ;(function() {
        var post = document.querySelector('article.post-content');

        if(post == null) {
            return;
        }

        (function iterate_node(node) {

            if (/^(?:p|ul|h\d|table)$/i.test(node.tagName)) {

                node.innerHTML = link(node.innerHTML);

            } else { // Node.ELEMENT_NODE
                for (var i = 0; i < node.childNodes.length; i++) {
                    iterate_node(node.childNodes[i]);
                }
            }
        })(post);

        function link(content) {
            content = content.replace(/\\\[\[(.+?)\]\]/g, '\\[\\[$1\\]\\]');
            content = content.replace(/\[\[(.+?)\]\]\{(.+?)\}/g, '<a href="../$1">$2</a>');
            content = content.replace(/\[\[(.+?)\]\]/g, '<a href="../$1">$1</a>');
            content = content.replace(/\\\[\\\[(.+?)\\\]\\\]/g, '[[$1]]');
            return content;
        }

    })();
</script>


<script src="/js/axios.min.js"></script>
<script async src="/js/parent.js"></script>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>
</footer>
    
</body>
</html>
