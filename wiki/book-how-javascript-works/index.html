<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>자바스크립트는 왜 그 모양일까? - 홍가뤼의 개인위키</title>

    <meta name="description" content="더글라스 크락포드가 알려주는 ...">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://honggaruy.github.io/wiki/book-how-javascript-works/">
    <link rel="alternate" type="application/rss+xml" title="홍가뤼의 개인위키" href="https://honggaruy.github.io/feed.xml">

    <meta property="og:type" content="website">
    <meta property="og:title" content="자바스크립트는 왜 그 모양일까?">
    <meta property="og:description" content="더글라스 크락포드가 알려주는 ...">
    <meta property="og:image" content="https://honggaruy.github.io/resources/icon/apple-touch-icon.png">
    <meta property="og:url" content="https://honggaruy.github.io/wiki/book-how-javascript-works/">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:url" content="https://honggaruy.github.io/wiki/book-how-javascript-works/">
    <meta name="twitter:title" content="자바스크립트는 왜 그 모양일까?">
    <meta name="twitter:description" content="더글라스 크락포드가 알려주는 ...">

    <link rel="apple-touch-icon" sizes="180x180" href="/resources/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/icon/favicon-16x16.png">
    <link rel="manifest" href="/resources/icon/site.webmanifest">




<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header class="header">
    <div>
        <a class="site-title" href="/">홍가뤼의 개인위키</a>
    </div>
    <div>
        <a class="site-title-right" href="/about/">me</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/#random" onclick="if(typeof random === 'function')random()">random</a>
    </div>
    <div>
        <a class="site-title-right" href="/blog/">blog</a>
    </div>
    <div>
        <a class="site-title-right" href="/wiki/index/">wiki</a>
    </div>
</header>

    
        <div class="page-content">
            <div class="search">
    <form role="search" method="get" action="/search/">
         <input name="searchString" class="searchInput" placeholder=" 검색하세요" type="text">
         <input type="submit" class="searchButton" value="Search">
    </form>
</div>
            <div class="post">
                
<input type="hidden" id="thisName" value="book-how-javascript-works">
<div class="post">
    <header class="post-header">
        <h1 class="post-title">자바스크립트는 왜 그 모양일까?</h1>
    
        <p class="title-summary">더글라스 크락포드가 알려주는 ...</p>
    
        <div class="history-button">
            <p><a href="https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-how-javascript-works.md" target="_blank">created: 2020.12.01</a></p>
            <p><a href="https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-how-javascript-works.md" target="_blank">updated: 2021.04.04</a></p>
            <p>
                <a href="https://github.com/honggaruy/honggaruy.github.io/edit/master/_wiki/book-how-javascript-works.md">편집하기</a>
                
            </p>
        </div>
        <div id="parent-list"></div>


    <div class="post-tag">
    br*** book
</div>




    </header>
    <article class="post-content">
        <ul id="markdown-toc">
  <li>
<a href="#%EA%B0%9C%EC%9A%94" id="markdown-toc-개요">개요</a>    <ul>
      <li>
<a href="#%EC%A0%80%EC%9E%90-%EC%84%A4%EB%AA%85" id="markdown-toc-저자-설명">저자 설명</a>        <ul>
          <li><a href="#%EB%8D%94%EA%B8%80%EB%9F%AC%EC%8A%A4-%ED%81%AC%EB%9D%BD%ED%8F%AC%EB%93%9C" id="markdown-toc-더글러스-크락포드">더글러스 크락포드</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="#number-0-chapter-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90" id="markdown-toc-number-0-chapter-시작하기-전에">{“number”: 0, “chapter”: “시작하기 전에”}</a>    <ul>
      <li><a href="#%EC%9D%B4%EB%8B%A8" id="markdown-toc-이단">이단</a></li>
      <li><a href="#%EC%BD%94%EB%93%9C" id="markdown-toc-코드">코드</a></li>
      <li><a href="#%EB%8B%A4%EC%9D%8C-%EC%84%B8%EB%8C%80-%EC%96%B8%EC%96%B4" id="markdown-toc-다음-세대-언어">다음 세대 언어</a></li>
      <li><a href="#%EC%98%81%EC%96%B4---%EC%9D%B4-%EB%8B%A8%EB%9D%BD%EC%9D%84-%EC%9D%BD%EC%96%B4%EB%B3%B4%EB%A9%B4-%EC%9D%B4-%EC%82%AC%EB%9E%8C-%EC%84%B1%EA%B2%A9%EB%B0%8F-%EA%B3%A0%EC%A7%91-%EC%A0%95%EB%8F%84%EB%A5%BC-%EC%95%8C-%EC%88%98-%EC%9E%88%EB%8B%A4" id="markdown-toc-영어---이-단락을-읽어보면-이-사람-성격및-고집-정도를-알-수-있다">영어 - 이 단락을 읽어보면 이 사람 성격및 고집 정도를 알 수 있다….</a></li>
      <li><a href="#%EC%98%88%EC%A0%9C" id="markdown-toc-예제">예제</a></li>
    </ul>
  </li>
  <li>
<a href="#number-1-chapter-%EC%9D%B4%EB%A6%84" id="markdown-toc-number-1-chapter-이름">{“number”: 1, “chapter”: “이름”}</a>    <ul>
      <li><a href="#%EC%98%88%EC%95%BD%EC%96%B4" id="markdown-toc-예약어">예약어</a></li>
    </ul>
  </li>
  <li>
<a href="#number-2-chapter-%EC%88%AB%EC%9E%90" id="markdown-toc-number-2-chapter-숫자">{“number”: 2, “chapter”: “숫자”}</a>    <ul>
      <li><a href="#%EC%98%810" id="markdown-toc-영0">영(0)</a></li>
      <li><a href="#%EC%88%AB%EC%9E%90-%EB%A6%AC%ED%84%B0%EB%9F%B4" id="markdown-toc-숫자-리터럴">숫자 리터럴</a></li>
      <li><a href="#number" id="markdown-toc-number">Number</a></li>
      <li>
<a href="#%EC%97%B0%EC%82%B0%EC%9E%90" id="markdown-toc-연산자">연산자</a>        <ul>
          <li><a href="#%EC%A0%84%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90" id="markdown-toc-전위-연산자">전위 연산자</a></li>
          <li><a href="#%EC%A4%91%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90" id="markdown-toc-중위-연산자">중위 연산자</a></li>
          <li><a href="#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC" id="markdown-toc-참고링크">참고링크</a></li>
        </ul>
      </li>
      <li>
<a href="#%EB%B9%84%ED%8A%B8-%EB%8B%A8%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90" id="markdown-toc-비트-단위-연산자">비트 단위 연산자</a>        <ul>
          <li>
<a href="#javascript%EC%9D%98-bitwise-operator%EA%B0%80-%EC%9E%98-%EC%93%B0%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0" id="markdown-toc-javascript의-bitwise-operator가-잘-쓰이지-않는-이유">Javascript의 Bitwise Operator가 잘 쓰이지 않는 이유</a>            <ul>
              <li><a href="#%EB%8B%A4%EB%A5%B8-%EC%96%B8%EC%96%B4%EC%97%90%EC%84%9C%EB%8A%94-%EB%90%98%EB%8A%94%EB%8D%B0-javascript%EC%97%90%EC%84%9C%EB%8A%94-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%83%EB%93%A4" id="markdown-toc-다른-언어에서는-되는데-javascript에서는-안되는-것들">다른 언어에서는 되는데 Javascript에서는 안되는 것들</a></li>
              <li><a href="#%EC%8B%AC%EC%A7%80%EC%96%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8D%B0%EB%8F%84-%EC%9C%84%ED%97%98%EC%9D%84-%EC%B4%88%EB%9E%98" id="markdown-toc-심지어-사용하지-않는데도-위험을-초래">심지어 사용하지 않는데도 위험을 초래</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="#number-7-chapter-%EB%B0%B0%EC%97%B4" id="markdown-toc-number-7-chapter-배열">{“number”: 7, “chapter”: “배열”}</a>    <ul>
      <li><a href="#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9B%90%EC%A0%90" id="markdown-toc-배열의-원점">배열의 원점</a></li>
      <li><a href="#%EC%B4%88%EA%B8%B0%ED%99%94" id="markdown-toc-초기화">초기화</a></li>
      <li><a href="#%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%81%90" id="markdown-toc-스택과-큐">스택과 큐</a></li>
    </ul>
  </li>
  <li><a href="#%EB%8B%A4%EB%A5%B8-%EC%B1%84%ED%94%84%ED%84%B0" id="markdown-toc-다른-채프터">다른 채프터</a></li>
</ul>

<h1 id="개요">개요</h1>

<table>
  <tbody>
    <tr>
      <td><img src="http://image.kyobobook.co.kr/images/book/xlarge/595/x9788966262595.jpg" alt="표지"></td>
      <td>저자: 더글러스 크락포드 (Douglas Crockford) <br> 책제목 : 자바스크립트는 왜 그 모양일까? (원제 : How JavaScript Works) <br> 부제 : 더글러스 크락포드가 알려주는 <br> 위험한 자바스크립트를 안전하게 사용하는 법 <br> 출판사 : 인사이트 <br> ISBN 한글 : 978-89-6626-259-5 <br> ISBN 영문 : 978-1949815009 <br> <br> 값: 28,000원</td>
    </tr>
  </tbody>
</table>

<h2 id="저자-설명">저자 설명</h2>

<h3 id="더글러스-크락포드">더글러스 크락포드</h3>

<ul>
  <li>더글러스 크락포드는 자바스크립트 구루(Guru)라고 불리지만, 구루보다는 사실 성인(Mahatma)에 가깝다
    <ul>
      <li>(내생각) 번역한 책을 읽어보면 말하는 스타일이 … 그런 스타일이라는 걸 알 수 있다.</li>
    </ul>
  </li>
  <li>JSON 창시자, JSLint, JSMin 도구 개발</li>
  <li><a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford, 영문위키</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%EB%8D%94%EA%B8%80%EB%9D%BC%EC%8A%A4_%ED%81%AC%EB%A1%9D%ED%8F%AC%EB%93%9C">더글러스 크록포드, 한글위키</a></li>
  <li><a href="https://www.codemotion.com/magazine/dev-hub/web-developer/douglas-crockford-presents-his-new-book-how-javascript-works/">관련기사 : Douglas Crockford and his book “How JavaScript works”</a></li>
  <li><a href="https://github.com/douglascrockford">Douglas Crockford, github</a></li>
  <li>
<a href="https://www.crockford.com/isbn-13.html">Douglas Crockford, homepage</a>
    <ul>
      <li><a href="https://www.crockford.com/about.html">Douglas Crockford, 소개페이지</a></li>
    </ul>
  </li>
</ul>

<h1 id="number-0-chapter-시작하기-전에">{“number”: 0, “chapter”: “시작하기 전에”}</h1>

<ul>
  <li>제가 사용하는 프로그래밍 언어를 다루는 스킬을 향상시키는 가장 효과적인 방법은 다음과 같습니다
    <blockquote>
      <p>이따금 유용하지만 때때로 위험한 기능과 안전하면서 더 나은 다른 기능이 있다면, 항상 더 나은 다른 기능을 사용하라</p>
    </blockquote>
  </li>
  <li>(내생각) 현재 Javascript 표준에 대해 대단히 비판적인 관점을 가지고 있다.
    <ul>
      <li>십년 전과 비교했을 때 자바스크립트의 좋은 부분은 점점 더 적어지긴 했지만, 대행히 좋은 부분은 훨씬 더 좋아지고 있습니다.</li>
      <li>ECMA-Script 표준 개정안은 자바스크립트의 본질적인 문제를 해결하지 않고, 오히려 새로운 문제를 일으키기도 합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="이단">이단</h2>

<ul>
  <li>더글라스 크락포드는 공격받는데 익숙하지만 대체로 옳았다고 본인이 생각함 ( Javascirpt를 옹호했을때, JSON을 창시했을 때)</li>
  <li>이 책의 관점이 이단이라고 공격받을 수 있다는 점을 암시</li>
</ul>

<h2 id="코드">코드</h2>

<ul>
  <li>코드는 공개되어 있음</li>
  <li>
<a href="http://howjavascriptworks.com/erratums/">원서의 정오표</a> - 2020-12-01 현재 발견된 에러가 없다고 한다….</li>
  <li>
<a href="https://bit.ly/33d6t0R">번역서의 정오표</a> - 2020-12-01 2개 있음</li>
</ul>

<h2 id="다음-세대-언어">다음 세대 언어</h2>

<ul>
  <li>전 아이들이 미래라고 믿습니다. 아, 물론 로봇도요. ( 로봇 예찬론자인가..)</li>
  <li>다음 프로그래밍 패러다임은 <code class="language-html highlighter-rouge">분산 비동기 프로그래밍</code>
    <ul>
      <li>기존의 패러다임은 지역적, 불안전하며, 순차적인 패러다임, Javascript도 마찬가지</li>
    </ul>
  </li>
</ul>

<h2 id="영어---이-단락을-읽어보면-이-사람-성격및-고집-정도를-알-수-있다">영어 - 이 단락을 읽어보면 이 사람 성격및 고집 정도를 알 수 있다….</h2>

<ul>
  <li>(내생각) 이사람의 코딩 예제 중에 <code class="language-html highlighter-rouge">wun</code> 혹은 <code class="language-html highlighter-rouge">wunth</code>로 명명한 이름이 있는데 구글에 물어봐도 의미를 알기어렵다. 이 단락에 설명이 되어있다</li>
  <li>one → wun
    <ul>
      <li>숫자 1에 대한 영어 단어인 one은 제가 일부러 다른 철자를 사용하고 있습니다</li>
      <li>저는 <code class="language-html highlighter-rouge">wun</code>이 올바른 철자라고 생각합니다
        <ul>
          <li>one의 발음은 그 어떤 영어 발음 방식과도 들어맞지 않습니다</li>
          <li>(내생각)<code class="language-html highlighter-rouge">원</code>이라는 발음에 맞춰 본인이 단어를 만든건가???</li>
        </ul>
      </li>
      <li>숫자 1을 의미하는 단어가 숫자 0으로 보이는 알파벳으로 시작하는 건 버그처럼 보임</li>
      <li>wun이 익숙하지 않아 불편하겠지만 불편이 잘못이 아니라는 걸 보여주기 위해 계속 사용할테니 니들이 참으셈..</li>
    </ul>
  </li>
  <li>through → thru
    <ul>
      <li>through 철자는 절반이 묵음이며 언어를 배우는 학생에게 불필요한 부담을 주고 있음</li>
      <li>thru가 더 낫지 않음?</li>
      <li>철자를 바꾸는 것은 전통과 이유간의 대립, 가끔 이유가 이기기도 함</li>
      <li>one → wun 바꾸는 운동에 당신도 동참하길 … (선동중임)</li>
    </ul>
  </li>
  <li>개발자와 비개발자의 차이점
    <ul>
      <li>1 to 10?
        <ul>
          <li>개발자 : 1 ~ 9 ( 10제외 , 0 부터 시작하는 인덱싱 버릇)</li>
          <li>일반인 : 1 ~ 10 ( 10포함 )</li>
        </ul>
      </li>
      <li>더.크가 앞으로 사용할 지침
        <ul>
          <li>0 to 3 = 0, 1, 2 포함 (개발자의 to 의미)</li>
          <li>0 thru 3 = 0, 1, 2, 3 포함 ( 일반인의 to 의미)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="예제">예제</h2>

<ul>
  <li>정규표현식은 공백이 없어 이해하기 힘듬</li>
  <li>이해를 돕기 위해 정규표현식에 공백을 추가함</li>
  <li>실제 적용하려면 공백문자를 없애고 사용하셈</li>
</ul>

<h1 id="number-1-chapter-이름">{“number”: 1, “chapter”: “이름”}</h1>

<ul>
  <li>모든 이름은 문자로 시작하여 문자로 끝낼것
    <ul>
      <li>_(밑줄)로 시작하는 이름은 일반적으로 public 속성이나 전역변수
        <ul>
          <li>이런 변수는 모두 private으로 할 수 있음.</li>
          <li>앞이나 뒤에 밑줄을 쓰는 것 개발자의 무능을 의미</li>
        </ul>
      </li>
      <li>$(달러) 기호는 코드 생성기에서 사용할 목적으로 추가됨
        <ul>
          <li>당신이 코드 생성기가 아니라면 사용하지 말것</li>
        </ul>
      </li>
      <li>이름에 숫자가 들어가는 경우는 개발자가 이름에 대해 충분히 생각하지 않았다는 증거
        <ul>
          <li>순서를 나타내는 서수형 변수 : thing_nr =&gt; person_one</li>
          <li>크기를 나타내는 기수형 변수 : nr_things =&gt; two_persons</li>
        </ul>
      </li>
      <li>Javascript가 위의 이름을 허용하는 것은 해서는 안될일</li>
    </ul>
  </li>
  <li>이름에 공백이 허용되어야 한다고 생각 ( 내 생각은 지금이 더 좋은듯 한데 … keyword와 구별이 안될 수 있을듯)
    <ul>
      <li>차선으로 단어간 연결을 _(밑줄)로 연결 ( 나중에 공백으로 바뀌면 바꾸기 더 좋기 때문에)</li>
      <li>(내생각) 나는 CamelCase 파임.</li>
    </ul>
  </li>
  <li>모든 이름은 소문자로 시작해야함 - 잘 이해가 안되는 부분..
    <ul>
      <li>new 연산자 때문</li>
      <li>함수 호출문이 new로 시작하면 해당 함수는 생성자로서 호출됨. 아니면 그냥 함수로 호출</li>
      <li>생성자와 함수의 기능은 완전히 다르고 잘못 호출할 경우 문제 발생.</li>
      <li>더 안좋은 상황은 생성자와 함수는 겉보기가 같아 자동으로 감지하기가 힘듬 (JSLint같은 도구??)</li>
      <li>에러를 감지하기 위한 시작적인 표시의 제안
        <blockquote>
          <p>모든 생성자 함수의 이름은 대문자로 시작되어야 하며, 그렇지 않은 모든 경우에는 소문자로 시작되어야 함</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>좀 더 믿을 만한 방법 - 극단적인 방법??
    <ul>
      <li>절대 new를 사용하지 말것</li>
      <li>new를 쓰지 않으면 대문자로 시작할 일이 없음</li>
      <li>때문에 모든 이름을 소문자로 쓸 것…</li>
    </ul>
  </li>
</ul>

<h2 id="예약어">예약어</h2>

<ul>
  <li>예약어는 컴퓨터 메모리가 부족하던 50~60년대의 어쩔수 없는 선택</li>
  <li>현재는 의미없는 제한된 사고 방식</li>
  <li>불안정한 예약어 전략은 언어에 새로운 기능을 깔끔하고 직관적으로 추가하기 어렵게 만듬</li>
  <li>앞으로는 예약어 없는 언어가 개발되길..</li>
</ul>

<h1 id="number-2-chapter-숫자">{“number”: 2, “chapter”: “숫자”}</h1>

<ul>
  <li>자바스크립트는 숫자형이 number 하나라는 이유로 자주 비판받았습니다
    <ul>
      <li>하지만 이는 자바스크립트의 아주 큰 강점중 하나입니다</li>
      <li>어떤 숫자형을 사용할 지 고민할 필요가 없어 생산성 증가</li>
      <li>타입 변환 오류, int형의 오버플로우 오류에서 자유로움</li>
      <li>자바의 정수보다 훨씬 안정적
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre><span class="nx">자바스크립트</span> <span class="p">:</span> <span class="mi">2147483647</span> <span class="o">+</span> <span class="mi">1</span>      <span class="c1">// 2147483648 정확하게 맞음</span>
<span class="nx">자바</span>         <span class="p">:</span> <span class="mi">2147483647</span> <span class="o">+</span> <span class="mi">1</span>      <span class="c1">// -2147483648 완전히 잘못됨 </span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
      <li>위의 경우 자바는 아무런 경고없이 언제든 잘못될 수 있는 숫자 시스템임
        <ul>
          <li>int형은 오류를 방지하지 못하며 오히려 오류를 유발함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>number는 IEEE 754 부동소수점 연산 표준을 따름
    <ul>
      <li>IEEE 754 표준 전체가 아니라 일부분중 일부분만 사용</li>
      <li>자바스크립트의 number는 자바의 double과 아주 밀접
        <ul>
          <li>64비트 2진 부동소수점 타입</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="영0">영(0)</h2>

<ul>
  <li>0이 하나만 존재하는 것이 제대로 된 시스템</li>
  <li>두 개의 0
    <ul>
      <li>이상한 현상 : IEEE 754 표준에는 0과 -0 이라는 두 개의 0이 존재</li>
      <li>아래의 경우를 제외하면 -0의 존재를 무시해도 됨
        <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span>    <span class="c1">// false</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span>        <span class="c1">// false</span>
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>0으로 무언가를 나누거나 Object.is()를 굳이 사용할 필요도 없으니 무시해도 됨</li>
</ul>

<h2 id="숫자-리터럴">숫자 리터럴</h2>

<ul>
  <li>자바스크립트에는 18437736874454810627개의 불변 숫자 객체가 내장되어 있음
    <ul>
      <li>어떤 경우에는 딱 맞는 값이고</li>
      <li>또 어떤 경우는 9.979…e+291만큼 차이가 나기도 함</li>
    </ul>
  </li>
  <li>정수에 대한 숫자 리터럴은 연속한 10진수 숫자들</li>
  <li>다음 표현은 2018이라는 숫자에 대한 참조를 생성
    <ul>
      <li>2진수: 0b11111100010</li>
      <li>8진수: 0o3742</li>
      <li>10진수: 2018.00</li>
      <li>16진수: 0x7E2</li>
    </ul>
  </li>
  <li>Infinity는 표현하기에는 너무 큰 모든 숫자
    <ul>
      <li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Infinity">Infinity, MDN</a></li>
      <li>∞ 와 Infinity는 같지 않다 - 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY">Number.POSITIVE_INFINITY</a> 참조</li>
    </ul>
  </li>
  <li>NaN은 숫자가 아닌 숫자 - ‘Not a Number’
    <ul>
      <li>typeof 연산자가 NaN을 “number”형으로 표시하여 혼동을 줌</li>
      <li>문자열을 숫자로 변경하려다 실패하는 경우 반환되기도 함</li>
      <li>가장 혼동을 주는 부분
        <ul>
          <li>NaN과 NaN을 동등연산자로 비교하면 항상 실패함 ( IEEE 754 때문임 )</li>
          <li>값이 NaN인지를 테스트 하려면 Number.isNaN(value)를 사용해야함</li>
          <li>
<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/isFinite">Number.isFinite(value)</a>는 value = NaN, Infinity, -Infinity인 경우 false를 반환</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="number">Number</h2>

<ul>
  <li>Number : 숫자를 만드는 함수
    <ul>
      <li>Number에 new를 사용하면 안됨 - 기대하는 결과가 나오지 않음</li>
    </ul>
  </li>
  <li>number : 수에 대한 typeof 연산자가 반환하는 type</li>
  <li>몇가지 상수
    <ul>
      <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">Number.EPSILON</a>
        <ul>
          <li>가장 작은 양수 - 이보다 작으면 0으로 취급</li>
        </ul>
      </li>
      <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>
        <ul>
          <li>약 9천조의 값, 9007199254740991</li>
          <li>+,- 로 이 값의 범위에서만 안전한 연산이 가능</li>
          <li>Number.isSafeInteger(number)로 숫자의 연산안전성 확인가능</li>
        </ul>
      </li>
      <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE">Number.MAX_VALUE</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE">Number.MIN_VALUE</a>
        <ul>
          <li>계산 결과로 Safe를 넘는 값은 안전하지 않으므로 주의해야함</li>
          <li>Safe의 기준 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>
</li>
          <li>Number.MIN_VALUE는 0보다 큰 가장 작은 양수, 보다 작은 양수는 영과 구별이 안됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>그 외 Number.prototype의 메서드들은 그다지 유용하지 않음 ( 내 생각: 정말 그런가 ? )
    <ul>
      <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger">Number.isSafeInteger()</a> 는 어떻지?
        <ul>
          <li>Safe Integer란 ?
            <ul>
              <li>IEEE-754 double precision으로 정확히 표현가능한 수</li>
              <li>그 수의 IEEE-754 표현이 다른 정수를 IEEE-754 사양으로 반올림한 결과가 나오지 않는 수</li>
            </ul>
          </li>
          <li>예를 들면, $ 2 ^ {53} - 1 $ 은 Safe Integer임
            <ul>
              <li>이 숫자는 정확히 표현될 수 있는 숫자이며</li>
              <li>IEEE-754 rounding 모드에서 다른 정수가 이 숫자로 반올림 되지 않음.</li>
            </ul>
          </li>
          <li>반면에, $ 2 ^ {53} $ 은 Safe Interger가 아님.
            <ul>
              <li>이 숫자는 IEEE-754로 정확히 표현될 수는 있지만,</li>
              <li>$ 2 ^ {53} + 1 $ 이 <code class="language-html highlighter-rouge">round-to-nearset</code>와 <code class="language-html highlighter-rouge">round-to-zero</code> rounding  모드에서 $ 2 ^ {53} $ 으로 반올림 되기 때문</li>
            </ul>
          </li>
          <li>여기에 사용한 <code class="language-html highlighter-rouge">Mathjax</code>가 렌더링 안되고 있는데 <a href="https://github.com/jeffreytse/jekyll-spaceship/issues/50">현재 문의중임</a>.
            <ul>
              <li><a href="https://github.com/jeffreytse/jekyll-spaceship/issues/50#issuecomment-812444737">2021-04-02 고쳐짐</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="연산자">연산자</h2>

<h3 id="전위-연산자">전위 연산자</h3>

<ul>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus">Unary plus (+), MDN</a> , 전위 연산자 타입
    <ul>
      <li>문자열 숫자를 숫자타입으로 바꾸는 가장 빠르고 선호되는 방법 ( unary negation 보다 선호됨)
        <ul>
          <li>책에는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">Number 함수, MDN</a>가 명확하기 때문에 더 선호된다고 나옴</li>
        </ul>
      </li>
      <li>피연산자를 숫자로 바꾸는 것외에 다른 동작을 하지 않는다.</li>
      <li>변환에 실패하면 NaN을 반환</li>
    </ul>
  </li>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_negation">Unary negation (-), MDN</a> , 전위 연산자 타입
    <ul>
      <li>부호 변환이 주요 동작</li>
      <li>Javascript의 숫자 리터럴은 부호가 없음
        <ul>
          <li>(-1) 표현식에서 - 부호는 연산자이지 숫자 리터럴의 일부가 아님</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#typeof">typeof, MDN Guide</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">typeof, MDN Ref</a>, 전위 연산자 타입
    <ul>
      <li>피연산자의 타입을 알려주는 문자열을 반환함</li>
      <li>피연산자가 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN">NaN(Not a Number)</a>일 때도 “number”를 반환한다는 것을 주의할 것. <code class="language-html highlighter-rouge">Number.NaN</code> 과 같은 값.</li>
    </ul>
  </li>
</ul>

<h3 id="중위-연산자">중위 연산자</h3>

<ul>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Addition"> Addition (+) 연산자, MDN Ref</a>
    <ul>
      <li>
<code class="language-html highlighter-rouge">+</code> 연산자는 문자열 연결에도 사용하기 때문에 아주 위험함</li>
      <li>하나의 피연산자가 문자열이면 <code class="language-html highlighter-rouge">묻지도 따지지도 않고</code> 나머지 연산자를 문자열로 변환하여 연결함</li>
      <li>자바스크립트에는 더하기를 할 수있는 다른 방법도 없음</li>
      <li>피 연산자들이 숫자로서 제대로 더하기 연산이 되는지 확인하려면 Number 함수를 사용할 것</li>
    </ul>
  </li>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Division"> Division (/) 연산자, MDN Ref</a>
    <ul>
      <li>
<code class="language-html highlighter-rouge">정수</code> 나누기가 아님에 주의. 예를 들면 5/2 는 2가 아니라 2.5임에 주의</li>
    </ul>
  </li>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder"> Remainder (%) 연산자, MDN Ref</a>
    <ul>
      <li>
<a href="https://realpython.com/python-modulo-operator/#modulo-operator-with-a-negative-operand">Modulo 연산자, Real Python</a>가 아님에 주의. Remainder(나머지) 연산자임 (Javascript는 Modulo 연산자가 없음)</li>
      <li>더글라스 크락포드는 Modulo 연산자가 훨씬 쓸모있다고 생각
        <ul>
          <li>Javascript의 Remainder 연산자의 결과는 divideend(피제수, 나눠지는 수)의 부호를 따름
            <ul>
              <li>예를 들면, 8 % -3 = 2</li>
            </ul>
          </li>
          <li>Python및 다른 언어의 Modulo 연산 결과는 divisor(제수, 나누는 수)의 부호를 따름.
            <ul>
              <li>예를 들면, 8 % -3 = -1</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>설명을 읽어봐도 어느게 더 좋은지는 잘 모르겠지만…
        <ul>
          <li>결과가 달라지는 부분에 대한 설명은 위의 Real Python 링크를 읽어볼것</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="참고링크">참고링크</h3>

<ul>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">Expressions and operators, MDN</a>
    <ul>
      <li>전위 / 후위 연산자 = unary operator</li>
      <li>중위 연산자 = binary operator</li>
    </ul>
  </li>
</ul>

<h2 id="비트-단위-연산자">비트 단위 연산자</h2>

<ul>
  <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">Bitwise operators, MDN</a>
    <ul>
      <li>피연산자들을 32 bits binary 수 (zeros and ones)로 변환.</li>
      <li>결과는 표쥰 Javascript numerical values로 반환</li>
    </ul>
  </li>
</ul>

<h3 id="javascript의-bitwise-operator가-잘-쓰이지-않는-이유">Javascript의 Bitwise Operator가 잘 쓰이지 않는 이유</h3>

<ul>
  <li>안전하게 하려면 54 bit 정수형으로 변환해서 사용하는게 좋은데 Javascript는 안 그러고 있음
    <ul>
      <li>그 결과 상위 22 bit는 경고없이 사라질 수 있음</li>
      <li>참고 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Bitwise_logical_Operators">Bitwise logical operators</a>
</li>
    </ul>
  </li>
</ul>

<h4 id="다른-언어에서는-되는데-javascript에서는-안되는-것들">다른 언어에서는 되는데 Javascript에서는 안되는 것들</h4>

<ul>
  <li><a href="https://realpython.com/python-bitwise-operators/#bitwise-shift-operators">몇몇 언어에서 Shift는 곱하기나 나누기의 대용으로 사용됨, Python의 예, Real Python</a></li>
  <li><a href="https://mziccard.me/2015/05/08/modulo-and-division-vs-bitwise-operations/">bitwise <code class="language-html highlighter-rouge">and</code>는 modulot 연산자로 사용하기도 함</a></li>
  <li>하지만, Javascript에서는 이렇게 할 수 없음.
    <ul>
      <li>최상위 22개비트를 버리는 꼴</li>
    </ul>
  </li>
</ul>

<h4 id="심지어-사용하지-않는데도-위험을-초래">심지어 사용하지 않는데도 위험을 초래</h4>

<ul>
  <li>
<code class="language-html highlighter-rouge"><span class="err">&amp;</span></code>(앰퍼샌드)와 <code class="language-html highlighter-rouge">|</code>(수직바)는 <code class="language-html highlighter-rouge"><span class="err">&amp;&amp;</span></code>(앰퍼샌드 두개)와 <code class="language-html highlighter-rouge">||</code>(수직바 두개)와 혼동하기 쉬움</li>
  <li>
<code class="language-html highlighter-rouge"><span class="nt">&lt;</span><span class="err">&lt;</span></code>와 <code class="language-html highlighter-rouge">&gt;&gt;</code>역시 <code class="language-html highlighter-rouge"><span class="nt">&lt;</span></code>, <code class="language-html highlighter-rouge">&gt;</code>와 헷갈림</li>
  <li>(더글라스 크록포드 생각) <code class="language-html highlighter-rouge">&gt;&gt;</code>가 왜 부호를 확장하는 오른쪽 Shift 연산자이고 <code class="language-html highlighter-rouge">&gt;&gt;&gt;</code>는 왜 아닌지 모르겠음.</li>
  <li>C 언어의 경우, 부호의 확장은 자료형에 따라 결정됨. <a href="https://docs.oracle.com/cd/E19205-01/819-5265/bjamz/index.html">Sign Extension, C User’s Guide, Oracle</a>
</li>
  <li>Java의 경우, 부호의 확장은 연산자에 의해 정해짐. <a href="https://mkyong.com/java/java-sign-extension/">Java Sign Extension, mkyong’s blog</a>
    <ul>
      <li>Javascript는 Java의 잘못된 결정을 그대로 따름. 조심해야 함. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Unsigned right shift (»&gt;), MDN Ref</a>
</li>
    </ul>
  </li>
</ul>

<h1 id="number-7-chapter-배열">{“number”: 7, “chapter”: “배열”}</h1>

<ul>
  <li>배열에 관한 몇가지 흥미로운 사실
    <ul>
      <li>자바스크립트 초기 배포시에는 배열이 없었다
        <ul>
          <li>객체가 너무 강력했고, 성능문제만 뺀다면 객체는 배열이 할 수 있는 모든것을 할 수 있다.</li>
        </ul>
      </li>
      <li>배열의 색인으로 어떤 문자열이나 사용가능</li>
      <li>배열은 real 객체</li>
    </ul>
  </li>
  <li>Javascript의 배열이 객체와 다른 4가지 포인트
    <ol>
      <li>배열은 length 속성을 가짐
        <ul>
          <li>Array.length는 요소의 갯수가 아님 - 가장의 큰 index보다 1 큰 수</li>
        </ul>
        <ul>
          <li>Javascript의 배열이 진짜 배열인 것 같은 환상을 보여줌. for 문 처리 가능</li>
        </ul>
      </li>
      <li>배열은 Object.prototype 보다 훨씬 더 좋은 메서드들을 가진 Array.prototype을 상속</li>
      <li>배열은 Object literal이 아닌 Array literal로 생성됨
        <ul>
          <li>Array literal이 훨씬 더 간단, [ ] 혹은 [1, 2] 로 간단하게 생성됨</li>
        </ul>
      </li>
      <li>JSON은 배열과 객체를 다르게 취급, Javascript는 둘을 비슷하게 처리</li>
    </ol>
  </li>
  <li>Javascript로 배열과 객체를 구분하는 법
    <ul>
      <li>typedof 연산자로는 배열과 객체를 구분할 수 없음. 모두 실질적으로 객체임</li>
      <li>배열이 배열인지 확인하려면 Array.isArray(value)를 사용해야 함</li>
    </ul>
  </li>
</ul>

<h2 id="배열의-원점">배열의 원점</h2>

<ul>
  <li>인덱스를 0 부터 시작해야하는지 1 부터 시작해야하는지에 대한 논쟁
    <ul>
      <li>배열을 처리할 때 하나씩 처리하기보다, 함수로 처리하면 원점에 대한 논쟁이 필요없음</li>
      <li>배열의 첫번째 요소를 지칭할 때 <code class="language-html highlighter-rouge">first</code> 보다는 <code class="language-html highlighter-rouge">zeroth</code> 라는 용어가 적당 (저자의 개인적 의견..)</li>
    </ul>
  </li>
</ul>

<h2 id="초기화">초기화</h2>

<ul>
  <li>배열을 만드는 두 가지 방법
    <div class="language-js highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td>
<td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">my_little_array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// 방법 1. new Array(정수)</span>
                    <span class="c1">// my_little_arra is [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>
<span class="kd">let</span> <span class="nx">same_thing</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>   <span class="c1">// 방법 2. 배열 리터럴</span>

<span class="nx">my_little_array</span> <span class="o">===</span> <span class="nx">same_thing</span>      <span class="c1">// false</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>같은 값으로 초기화되지만, 따로 선언되어 서로 다른 배열임</li>
  <li>다른 객체와 마찬가지로 실제 같은 배열인 경우에만 같은 것으로 판정</li>
</ul>

<h2 id="스택과-큐">스택과 큐</h2>

<ul>
  <li>push, pop 메서드로 배열을 stack처럼 쓸 수 있음</li>
  <li>
    <p>스택의 사용법, 아래 처럼 스택은 인터프리터나 계산기에서 주로 사용
<script async="" src="//jsfiddle.net/honggaruy/3wc9ybht/12/embed/js,result/dark/"></script></p>
  </li>
  <li>shift, unshift 메소드
    <ul>
      <li>shift : pop 메서드와 유사, 배열의 마지막 요소대신 0번째 요소를 제거하고 반환</li>
      <li>unshift : push와는 달리 배열의 가장 앞에 새로운 요소를 추가</li>
      <li>shift / unshift 는 pop과 push에 비해 많이 느림. 배열이 길수록 심하게 느림</li>
      <li>shift / push를 사용하여 배열의 가장 뒤에 새로운 아이템을 추가하고 가장 앞에서 아이템을 꺼내 쓰는 Queue를 구현할 수 있음.</li>
      <li>관련링크
        <ul>
          <li><a href="https://stackoverflow.com/a/1590262/9457247">push와 shift로 구현한 queue, 퍼포먼스를 논하는 댓글들을 확인할것</a></li>
          <li><a href="https://code.iamkate.com/javascript/queues/">JavaScript queues, shift를 사용하지 않고 performance를 높인 Queue</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="다른-채프터">다른 채프터</h1>

    </article>



</div>
<script>
    ;(function() {
        var tags = document.querySelectorAll('.post-tag');
        if(tags == null || tags.length < 1) {
            return;
        }

        for (var i = 0; i < tags.length; i++) {
            var item = tags[i];
            var tagList = item.innerHTML.trim();

            if(/^\s*$/.test(tagList)) {
                continue;
            }
            tagList = tagList.split(/\s+/)
                .map(function(tag) {
                    return `<a href="/tag/#${tag}">#${tag}</a>`;
                })
                .join(' ');
            tags[i].innerHTML = tagList;
        }
        return;
    })();
    ;(function() {
        var post = document.querySelector('article.post-content');

        if(post == null) {
            return;
        }

        (function iterate_node(node) {

            if (/^(?:p|ul|h\d|table)$/i.test(node.tagName)) {

                node.innerHTML = link(node.innerHTML);

            } else { // Node.ELEMENT_NODE
                for (var i = 0; i < node.childNodes.length; i++) {
                    iterate_node(node.childNodes[i]);
                }
            }
        })(post);

        function link(content) {
            content = content.replace(/\\\[\[(.+?)\]\]/g, '\\[\\[$1\\]\\]');
            content = content.replace(/\[\[(.+?)\]\]\{(.+?)\}/g, '<a href="../$1">$2</a>');
            content = content.replace(/\[\[(.+?)\]\]/g, '<a href="../$1">$1</a>');
            content = content.replace(/\\\[\\\[(.+?)\\\]\\\]/g, '[[$1]]');
            return content;
        }

    })();
</script>


<script src="/js/axios.min.js"></script>
<script async src="/js/parent.js"></script>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>
</footer>
    
</body>
</html>
